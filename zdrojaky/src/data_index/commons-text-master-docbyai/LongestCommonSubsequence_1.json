[
    {
        "signature": "private static int[] algorithmB(final CharSequence left, final CharSequence right)",
        "implementation": "private static int[] algorithmB(final CharSequence left, final CharSequence right) {\n        final int m = left.length();\n        final int n = right.length();\n        // Creating an array for storing two rows of DP table\n        final int[][] dpRows = new int[2][1 + n];\n        for (int i = 1; i <= m; i++) {\n            // K(0, j) <- K(1, j) [j = 0...n], as per the paper:\n            // Since we have references in Java, we can swap references instead of literal copying.\n            // We could also use a \"binary index\" using modulus operator, but directly swapping the\n            // two rows helps readability and keeps the code consistent with the algorithm description\n            // in the paper.\n            final int[] temp = dpRows[0];\n            dpRows[0] = dpRows[1];\n            dpRows[1] = temp;\n\n            for (int j = 1; j <= n; j++) {\n                if (left.charAt(i - 1) == right.charAt(j - 1)) {\n                    dpRows[1][j] = dpRows[0][j - 1] + 1;\n                } else {\n                    dpRows[1][j] = Math.max(dpRows[1][j - 1], dpRows[0][j]);\n                }\n            }\n        }\n        // LL(j) <- K(1, j) [j=0...n], as per the paper:\n        // We don't need literal copying of the array, we can just return the reference\n        return dpRows[1];\n    }",
        "called_methods": [
            "length",
            "charAt",
            "max"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "algorithmB",
        "javadoc": "/**\n     * An implementation of \"ALG B\" from Hirschberg's CACM '71 paper.\n     * Assuming the first input sequence is of size {@code m} and the second input sequence is of size\n     * {@code n}, this method returns the last row of the dynamic programming (DP) table when calculating\n     * the LCS of the two sequences in <em>O(m*n)</em> time and <em>O(n)</em> space.\n     * The last element of the returned array, is the size of the LCS of the two input sequences.\n     *\n     * @param left first input sequence.\n     * @param right second input sequence.\n     * @return last row of the dynamic-programming (DP) table for calculating the LCS of {@code left} and {@code right}\n     * @since 1.10.0\n     */"
    },
    {
        "signature": "private static String algorithmC(final CharSequence left, final CharSequence right)",
        "implementation": "private static String algorithmC(final CharSequence left, final CharSequence right) {\n        final int m = left.length();\n        final int n = right.length();\n        final StringBuilder out = new StringBuilder();\n        if (m == 1) { // Handle trivial cases, as per the paper\n            final char leftCh = left.charAt(0);\n            for (int j = 0; j < n; j++) {\n                if (leftCh == right.charAt(j)) {\n                    out.append(leftCh);\n                    break;\n                }\n            }\n        } else if (n > 0 && m > 1) {\n            final int mid = m / 2; // Find the middle point\n            final CharSequence leftFirstPart = left.subSequence(0, mid);\n            final CharSequence leftSecondPart = left.subSequence(mid, m);\n            // Step 3 of the algorithm: two calls to Algorithm B\n            final int[] l1 = algorithmB(leftFirstPart, right);\n            final int[] l2 = algorithmB(reverse(leftSecondPart), reverse(right));\n            // Find k, as per the Step 4 of the algorithm\n            int k = 0;\n            int t = 0;\n            for (int j = 0; j <= n; j++) {\n                final int s = l1[j] + l2[n - j];\n                if (t < s) {\n                    t = s;\n                    k = j;\n                }\n            }\n            // Step 5: solve simpler problems, recursively\n            out.append(algorithmC(leftFirstPart, right.subSequence(0, k)));\n            out.append(algorithmC(leftSecondPart, right.subSequence(k, n)));\n        }\n\n        return out.toString();\n    }",
        "called_methods": [
            "length",
            "charAt",
            "append",
            "subSequence",
            "algorithmB",
            "reverse",
            "algorithmC",
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "algorithmC",
        "javadoc": "/**\n     * An implementation of \"ALG C\" from Hirschberg's CACM '71 paper.\n     * Assuming the first input sequence is of size {@code m} and the second input sequence is of size\n     * {@code n}, this method returns the Longest Common Subsequence (LCS) of the two sequences in\n     * <em>O(m*n)</em> time and <em>O(m+n)</em> space.\n     *\n     * @param left first input sequence.\n     * @param right second input sequence.\n     * @return the LCS of {@code left} and {@code right}\n     * @since 1.10.0\n     */"
    },
    {
        "signature": "private static String reverse(final CharSequence s)",
        "implementation": "private static String reverse(final CharSequence s) {\n        return new StringBuilder(s).reverse().toString();\n    }",
        "called_methods": [
            "reverse",
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "reverse",
        "javadoc": ""
    },
    {
        "signature": "public Integer apply(final CharSequence left, final CharSequence right)",
        "implementation": "public Integer apply(final CharSequence left, final CharSequence right) {\n        // Quick return for invalid inputs\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Inputs must not be null\");\n        }\n        // Find lengths of two strings\n        final int leftSz = left.length();\n        final int rightSz = right.length();\n        // Check if we can avoid calling algorithmB which involves heap space allocation\n        if (leftSz == 0 || rightSz == 0) {\n            return 0;\n        }\n        // Check if we can save even more space\n        if (leftSz < rightSz) {\n            return algorithmB(right, left)[leftSz];\n        }\n        return algorithmB(left, right)[rightSz];\n    }",
        "called_methods": [
            "length",
            "algorithmB"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "apply",
        "javadoc": "/**\n     * Computes the longest common subsequence similarity score of two {@code CharSequence}'s passed as\n     * input.\n     *\n     * <p>\n     * This method implements a more efficient version of LCS algorithm which has quadratic time and\n     * linear space complexity.\n     * </p>\n     *\n     * <p>\n     * This method is based on newly implemented {@link #algorithmB(CharSequence, CharSequence)}.\n     * An evaluation using JMH revealed that this method is almost two times faster than its previous version.\n     * </p>\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return length of the longest common subsequence of {@code left} and {@code right}\n     * @throws IllegalArgumentException if either String input {@code null}\n     */"
    },
    {
        "signature": "public CharSequence logestCommonSubsequence(final CharSequence left, final CharSequence right)",
        "implementation": "public CharSequence logestCommonSubsequence(final CharSequence left, final CharSequence right) {\n        return longestCommonSubsequence(left, right);\n    }",
        "called_methods": [
            "longestCommonSubsequence"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "logestCommonSubsequence",
        "javadoc": "/**\n     * Computes the longest common subsequence between the two {@code CharSequence}'s passed as input.\n     *\n     * <p>\n     * Note, a substring and subsequence are not necessarily the same thing. Indeed, {@code abcxyzqrs} and\n     * {@code xyzghfm} have both the same common substring and subsequence, namely {@code xyz}. However,\n     * {@code axbyczqrs} and {@code abcxyzqtv} have the longest common subsequence {@code xyzq} because a\n     * subsequence need not have adjacent characters.\n     * </p>\n     *\n     * <p>\n     * For reference, we give the definition of a subsequence for the reader: a <em>subsequence</em> is a sequence that\n     * can be derived from another sequence by deleting some elements without changing the order of the remaining\n     * elements.\n     * </p>\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return the longest common subsequence found\n     * @throws IllegalArgumentException if either String input {@code null}\n     * @deprecated Deprecated as of 1.2 due to a typo in the method name.\n     * Use {@link #longestCommonSubsequence(CharSequence, CharSequence)} instead.\n     * This method will be removed in 2.0.\n     */"
    },
    {
        "signature": "public CharSequence longestCommonSubsequence(final CharSequence left, final CharSequence right)",
        "implementation": "public CharSequence longestCommonSubsequence(final CharSequence left, final CharSequence right) {\n        // Quick return\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"Inputs must not be null\");\n        }\n        // Find lengths of two strings\n        final int leftSz = left.length();\n        final int rightSz = right.length();\n\n        // Check if we can avoid calling algorithmC which involves heap space allocation\n        if (leftSz == 0 || rightSz == 0) {\n            return \"\";\n        }\n\n        // Check if we can save even more space\n        if (leftSz < rightSz) {\n            return algorithmC(right, left);\n        }\n        return algorithmC(left, right);\n    }",
        "called_methods": [
            "length",
            "algorithmC"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "longestCommonSubsequence",
        "javadoc": "/**\n     * Computes the longest common subsequence between the two {@code CharSequence}'s passed as\n     * input.\n     *\n     * <p>\n     * This method implements a more efficient version of LCS algorithm which although has quadratic time, it\n     * has linear space complexity.\n     * </p>\n     *\n     *\n     * <p>\n     * Note, a substring and subsequence are not necessarily the same thing. Indeed, {@code abcxyzqrs} and\n     * {@code xyzghfm} have both the same common substring and subsequence, namely {@code xyz}. However,\n     * {@code axbyczqrs} and {@code abcxyzqtv} have the longest common subsequence {@code xyzq} because a\n     * subsequence need not have adjacent characters.\n     * </p>\n     *\n     * <p>\n     * For reference, we give the definition of a subsequence for the reader: a <em>subsequence</em> is a sequence that\n     * can be derived from another sequence by deleting some elements without changing the order of the remaining\n     * elements.\n     * </p>\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return the longest common subsequence found\n     * @throws IllegalArgumentException if either String input {@code null}\n     * @since 1.2\n     */"
    },
    {
        "signature": "public int[][] longestCommonSubstringLengthArray(final CharSequence left, final CharSequence right)",
        "implementation": "public int[][] longestCommonSubstringLengthArray(final CharSequence left, final CharSequence right) {\n        final int[][] lcsLengthArray = new int[left.length() + 1][right.length() + 1];\n        for (int i = 0; i < left.length(); i++) {\n            for (int j = 0; j < right.length(); j++) {\n                if (i == 0) {\n                    lcsLengthArray[i][j] = 0;\n                }\n                if (j == 0) {\n                    lcsLengthArray[i][j] = 0;\n                }\n                if (left.charAt(i) == right.charAt(j)) {\n                    lcsLengthArray[i + 1][j + 1] = lcsLengthArray[i][j] + 1;\n                } else {\n                    lcsLengthArray[i + 1][j + 1] = Math.max(lcsLengthArray[i + 1][j], lcsLengthArray[i][j + 1]);\n                }\n            }\n        }\n        return lcsLengthArray;\n    }",
        "called_methods": [
            "length",
            "charAt",
            "max"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LongestCommonSubsequence.java",
        "name": "longestCommonSubstringLengthArray",
        "javadoc": "/**\n     * Computes the lcsLengthArray for the sake of doing the actual lcs calculation. This is the\n     * dynamic programming portion of the algorithm, and is the reason for the runtime complexity being\n     * O(m*n), where m=left.length() and n=right.length().\n     *\n     * @param left first character sequence\n     * @param right second character sequence\n     * @return lcsLengthArray\n     * @deprecated Deprecated as of 1.10. A more efficient implementation for calculating LCS is now available.\n     * Use {@link #longestCommonSubsequence(CharSequence, CharSequence)} instead to directly calculate the LCS.\n     * This method will be removed in 2.0.\n     */"
    }
]