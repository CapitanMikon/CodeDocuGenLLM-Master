[
    {
        "signature": "private int buffer(final int requestReadCount) throws IOException",
        "implementation": "private int buffer(final int requestReadCount) throws IOException {\n        final int actualReadCount = buffer.readFrom(super.in, requestReadCount);\n        eos = actualReadCount == EOS;\n        return actualReadCount;\n    }",
        "called_methods": [
            "readFrom"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "buffer",
        "javadoc": "/**\n     * Buffers the requested number of characters if available.\n     */"
    },
    {
        "signature": "private int bufferOrDrainOnEos(final int requestReadCount, final char[] target, final int targetIndex,\n        final int targetLength) throws IOException",
        "implementation": "private int bufferOrDrainOnEos(final int requestReadCount, final char[] target, final int targetIndex,\n        final int targetLength) throws IOException {\n        final int actualReadCount = buffer(requestReadCount);\n        return drainOnEos(actualReadCount, target, targetIndex, targetLength);\n    }",
        "called_methods": [
            "buffer",
            "drainOnEos"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "bufferOrDrainOnEos",
        "javadoc": "/**\n     * Reads a requested number of chars from the underlying reader into the buffer. On EOS, set the state is DRAINING,\n     * drain, and return a drain count, otherwise, returns the actual read count.\n     */"
    },
    {
        "signature": "private int drain(final char[] target, final int targetIndex, final int targetLength)",
        "implementation": "private int drain(final char[] target, final int targetIndex, final int targetLength) {\n        final int actualLen = Math.min(buffer.length(), targetLength);\n        final int drainCount = buffer.drainChars(0, actualLen, target, targetIndex);\n        toDrain -= drainCount;\n        if (buffer.isEmpty() || toDrain == 0) {\n            // nothing or everything drained.\n            toDrain = 0;\n        }\n        return drainCount;\n    }",
        "called_methods": [
            "min",
            "length",
            "drainChars",
            "isEmpty"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "drain",
        "javadoc": "/**\n     * Drains characters from our buffer to the given {@code target}.\n     */"
    },
    {
        "signature": "private int drainOnEos(final int readCountOrEos, final char[] target, final int targetIndex,\n        final int targetLength)",
        "implementation": "private int drainOnEos(final int readCountOrEos, final char[] target, final int targetIndex,\n        final int targetLength) {\n        if (readCountOrEos == EOS) {\n            // At EOS, drain.\n            if (buffer.isNotEmpty()) {\n                toDrain = buffer.size();\n                return drain(target, targetIndex, targetLength);\n            }\n            return EOS;\n        }\n        return readCountOrEos;\n    }",
        "called_methods": [
            "isNotEmpty",
            "size",
            "drain"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "drainOnEos",
        "javadoc": "/**\n     * Drains from the buffer to the target only if we are at EOS per the input count. If input count is EOS, drain and\n     * returns the drain count, otherwise return the input count. If draining, the state is set to DRAINING.\n     */"
    },
    {
        "signature": "private boolean isBufferMatchAt(final StringMatcher stringMatcher, final int pos)",
        "implementation": "private boolean isBufferMatchAt(final StringMatcher stringMatcher, final int pos) {\n        return stringMatcher.isMatch(buffer, pos) == stringMatcher.size();\n    }",
        "called_methods": [
            "isMatch",
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "isBufferMatchAt",
        "javadoc": "/**\n     * Tests if our buffer matches the given string matcher at the given position in the buffer.\n     */"
    },
    {
        "signature": "private boolean isDraining()",
        "implementation": "private boolean isDraining() {\n        return toDrain > 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "isDraining",
        "javadoc": "/**\n     * Tests if we are draining.\n     */"
    },
    {
        "signature": "public int read(final char[] target, final int targetIndexIn, final int targetLengthIn) throws IOException",
        "implementation": "public int read(final char[] target, final int targetIndexIn, final int targetLengthIn) throws IOException {\n        // The whole thing is inefficient because we must look for a balanced suffix to match the starting prefix\n        // Trying to substitute an incomplete expression can perform replacements when it should not.\n        // At a high level:\n        // - if draining, drain until empty or target length hit\n        // - copy to target until we find a variable start\n        // - buffer until a balanced suffix is read, then substitute.\n        if (eos && buffer.isEmpty()) {\n            return EOS;\n        }\n        if (targetLengthIn <= 0) {\n            // short-circuit: ask nothing, give nothing\n            return 0;\n        }\n        // drain check\n        int targetIndex = targetIndexIn;\n        int targetLength = targetLengthIn;\n        if (isDraining()) {\n            // drain as much as possible\n            final int drainCount = drain(target, targetIndex, Math.min(toDrain, targetLength));\n            if (drainCount == targetLength) {\n                // drained length requested, target is full, can only do more in the next invocation\n                return targetLength;\n            }\n            // drained less than requested, target not full.\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n        }\n        // BUFFER from the underlying reader\n        final int minReadLenPrefix = prefixEscapeMatcher.size();\n        // READ enough to test for an [optionally escaped] variable start\n        int readCount = buffer(readCount(minReadLenPrefix, 0));\n        if (buffer.length() < minReadLenPrefix && targetLength < minReadLenPrefix) {\n            // read less than minReadLenPrefix, no variable possible\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            targetIndex += drainCount;\n            final int targetSize = targetIndex - targetIndexIn;\n            return eos && targetSize <= 0 ? EOS : targetSize;\n        }\n        // PREFIX\n        // buffer and drain until we find a variable start, escaped or plain.\n        int balance = 0;\n        final StringMatcher prefixMatcher = stringSubstitutor.getVariablePrefixMatcher();\n        int pos = 0;\n        while (targetLength > 0) {\n            if (isBufferMatchAt(prefixMatcher, 0)) {\n                balance = 1;\n                pos = prefixMatcher.size();\n                break;\n            }\n            if (isBufferMatchAt(prefixEscapeMatcher, 0)) {\n                balance = 1;\n                pos = prefixEscapeMatcher.size();\n                break;\n            }\n            // drain first char\n            final int drainCount = drain(target, targetIndex, 1);\n            targetIndex += drainCount;\n            targetLength -= drainCount;\n            if (buffer.size() < minReadLenPrefix) {\n                readCount = bufferOrDrainOnEos(minReadLenPrefix, target, targetIndex, targetLength);\n                if (eos || isDraining()) {\n                    // if draining, readCount is a drain count\n                    if (readCount != EOS) {\n                        targetIndex += readCount;\n                        targetLength -= readCount;\n                    }\n                    final int actual = targetIndex - targetIndexIn;\n                    return actual > 0 ? actual : EOS;\n                }\n            }\n        }\n        // we found a variable start\n        if (targetLength <= 0) {\n            // no more room in target\n            return targetLengthIn;\n        }\n        // SUFFIX\n        // buffer more to find a balanced suffix\n        final StringMatcher suffixMatcher = stringSubstitutor.getVariableSuffixMatcher();\n        final int minReadLenSuffix = Math.max(minReadLenPrefix, suffixMatcher.size());\n        readCount = buffer(readCount(minReadLenSuffix, pos));\n        if (eos) {\n            // EOS\n            stringSubstitutor.replaceIn(buffer);\n            toDrain = buffer.size();\n            final int drainCount = drain(target, targetIndex, targetLength);\n            return targetIndex + drainCount - targetIndexIn;\n        }\n        // buffer and break out when we find the end or a balanced suffix\n        while (true) {\n            if (isBufferMatchAt(suffixMatcher, pos)) {\n                balance--;\n                pos++;\n                if (balance == 0) {\n                    break;\n                }\n            } else if (isBufferMatchAt(prefixMatcher, pos)) {\n                balance++;\n                pos += prefixMatcher.size();\n            } else if (isBufferMatchAt(prefixEscapeMatcher, pos)) {\n                balance++;\n                pos += prefixEscapeMatcher.size();\n            } else {\n                pos++;\n            }\n            readCount = buffer(readCount(minReadLenSuffix, pos));\n            if (readCount == EOS && pos >= buffer.size()) {\n                break;\n            }\n        }\n        // substitute\n        final int endPos = pos + 1;\n        final int leftover = Math.max(0, buffer.size() - pos);\n        stringSubstitutor.replaceIn(buffer, 0, Math.min(buffer.size(), endPos));\n        pos = buffer.size() - leftover;\n        final int drainLen = Math.min(targetLength, pos);\n        // only drain up to what we've substituted\n        toDrain = pos;\n        drain(target, targetIndex, drainLen);\n        return targetIndex - targetIndexIn + drainLen;\n    }",
        "called_methods": [
            "read",
            "isEmpty",
            "isDraining",
            "drain",
            "min",
            "size",
            "buffer",
            "readCount",
            "length",
            "replaceIn",
            "getVariablePrefixMatcher",
            "isBufferMatchAt",
            "bufferOrDrainOnEos",
            "getVariableSuffixMatcher",
            "max"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "read",
        "javadoc": "/**\n     * Reads characters into a portion of an array.\n     *\n     * @param target Target buffer.\n     * @param targetIndexIn Index in the target at which to start storing characters.\n     * @param targetLengthIn Maximum number of characters to read.\n     * @return The number of characters read, or -1 on end of stream.\n     * @throws IOException If an I/O error occurs\n     */"
    },
    {
        "signature": "private int readCount(final int count, final int pos)",
        "implementation": "private int readCount(final int count, final int pos) {\n        final int avail = buffer.size() - pos;\n        return avail >= count ? 0 : count - avail;\n    }",
        "called_methods": [
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\io\\StringSubstitutorReader.java",
        "name": "readCount",
        "javadoc": "/**\n     * Returns how many chars to attempt reading to have room in the buffer for {@code count} chars starting at position\n     * {@code pos}.\n     */"
    }
]