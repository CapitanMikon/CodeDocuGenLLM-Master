[
    {
        "signature": "public void close()",
        "implementation": "public void close() {\n            // do nothing\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "close",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void mark(final int readAheadLimit)",
        "implementation": "public void mark(final int readAheadLimit) {\n            mark = pos;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "mark",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public boolean markSupported()",
        "implementation": "public boolean markSupported() {\n            return true;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "markSupported",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public int read(final char[] b, final int off, int len)",
        "implementation": "public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = size() - pos;\n            }\n            TextStringBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }",
        "called_methods": [
            "ready",
            "charAt",
            "size",
            "getChars"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "read",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public boolean ready()",
        "implementation": "public boolean ready() {\n            return pos < size();\n        }",
        "called_methods": [
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "ready",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void reset()",
        "implementation": "public void reset() {\n            pos = mark;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "reset",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public long skip(long n)",
        "implementation": "public long skip(long n) {\n            if (pos + n > size()) {\n                n = size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos = Math.addExact(pos, Math.toIntExact(n));\n            return n;\n        }",
        "called_methods": [
            "size",
            "addExact",
            "toIntExact"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "skip",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public String getContent()",
        "implementation": "public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return TextStringBuilder.this.toString();\n            }\n            return str;\n        }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "getContent",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "protected List<String> tokenize(final char[] chars, final int offset, final int count)",
        "implementation": "protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(getBuffer(), 0, TextStringBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }",
        "called_methods": [
            "getBuffer",
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "tokenize",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void flush()",
        "implementation": "public void flush() {\n            // do nothing\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "flush",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void write(final String str, final int off, final int len)",
        "implementation": "public void write(final String str, final int off, final int len) {\n            TextStringBuilder.this.append(str, off, len);\n        }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "write",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "private static int createPositiveCapacity(final int minCapacity)",
        "implementation": "private static int createPositiveCapacity(final int minCapacity) {\n        if (minCapacity < 0) {\n            // overflow\n            throw new OutOfMemoryError(\"Unable to allocate array size: \" + Integer.toUnsignedString(minCapacity));\n        }\n        // This is called when we require buffer expansion to a very big array.\n        // Use the conservative maximum buffer size if possible, otherwise the biggest required.\n        //\n        // Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE.\n        // This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full\n        // Integer.MAX_VALUE length array.\n        // The result is that we may have to allocate an array of this size more than once if\n        // the capacity must be expanded again.\n        return Math.max(minCapacity, MAX_BUFFER_SIZE);\n    }",
        "called_methods": [
            "toUnsignedString",
            "max"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "createPositiveCapacity",
        "javadoc": "/**\n     * Creates a positive capacity at least as large the minimum required capacity.\n     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array\n     * can be allocated.\n     *\n     * @param minCapacity the minimum capacity\n     * @return the capacity\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n     */"
    },
    {
        "signature": "public static TextStringBuilder wrap(final char[] initialBuffer, final int length)",
        "implementation": "public static TextStringBuilder wrap(final char[] initialBuffer, final int length) {\n        return new TextStringBuilder(initialBuffer, length);\n    }",
        "called_methods": [
            "requireNonNull"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "wrap",
        "javadoc": "/**\n     * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n     * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n     * be initialized without copying the input array.\n     *\n     * @param initialBuffer The initial array that will back the new builder.\n     * @param length The length of the subarray to be used; must be non-negative and no larger than\n     *        {@code initialBuffer.length}. The new builder's size will be set to {@code length}.\n     * @return A new instance.\n     * @since 1.9\n     */"
    },
    {
        "signature": "public TextStringBuilder append(final TextStringBuilder str, final int startIndex, final int length)",
        "implementation": "public TextStringBuilder append(final TextStringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacityInternal(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacityInternal",
            "appendTrue",
            "appendFalse",
            "length",
            "appendNull",
            "arraycopy",
            "append",
            "hasArray",
            "remaining",
            "array",
            "arrayOffset",
            "position",
            "toString",
            "valueOf",
            "getChars",
            "format"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "append",
        "javadoc": "/**\n     * Appends part of a string builder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "* vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0)",
        "implementation": "public <T> TextStringBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot use @SafeVarargs, since this method is\n         * not final. Using @SuppressWarnings is fine, because it isn't inherited by subclasses, so each subclass must\n         * vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "forEach",
            "forEachRemaining",
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendAll",
        "javadoc": "/**\n     * Appends each item in an array to the builder without any separators. Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param <T> the element type\n     * @param array the array to append\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "private void appendFalse(int index)",
        "implementation": "private void appendFalse(int index) {\n        buffer[index++] = 'f';\n        buffer[index++] = 'a';\n        buffer[index++] = 'l';\n        buffer[index++] = 's';\n        buffer[index] = 'e';\n        size += FALSE_STRING_SIZE;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendFalse",
        "javadoc": "/** Appends {@code \"false\"}. */"
    },
    {
        "signature": "public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar)",
        "implementation": "public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacityInternal(size + width);\n            String str = Objects.toString(obj, getNullText());\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                final int toIndex = size + padLen;\n                Arrays.fill(buffer, size, toIndex, padChar);\n                str.getChars(0, strLen, buffer, toIndex);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "called_methods": [
            "appendFixedWidthPadLeft",
            "valueOf",
            "ensureCapacityInternal",
            "toString",
            "getNullText",
            "length",
            "getChars",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendFixedWidthPadLeft",
        "javadoc": "/**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code toString} of the object is\n     * used. If the object is larger than the length, the left hand side is lost. If the object is null, the null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)",
        "implementation": "public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacityInternal(size + width);\n            String str = Objects.toString(obj, getNullText());\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                str.getChars(0, strLen, buffer, size);\n                final int fromIndex = size + strLen;\n                Arrays.fill(buffer, fromIndex, fromIndex + width - strLen, padChar);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "called_methods": [
            "appendFixedWidthPadRight",
            "valueOf",
            "ensureCapacityInternal",
            "toString",
            "getNullText",
            "length",
            "getChars",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendFixedWidthPadRight",
        "javadoc": "/**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code toString} of the object is\n     * used. If the object is larger than the length, the right hand side is lost. If the object is null, null text\n     * value is used.\n     *\n     * @param obj the object to append, null uses null text\n     * @param width the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder appendln(final TextStringBuilder str, final int startIndex, final int length)",
        "implementation": "public TextStringBuilder appendln(final TextStringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }",
        "called_methods": [
            "append",
            "appendNewLine"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendln",
        "javadoc": "/**\n     * Appends part of a string builder followed by a new line to this string builder. Appending null will call\n     * {@link #appendNull()}.\n     *\n     * @param str the string to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length the length to append, must be valid\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder appendNewLine()",
        "implementation": "public TextStringBuilder appendNewLine() {\n        if (newLine == null) {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }",
        "called_methods": [
            "append",
            "lineSeparator"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendNewLine",
        "javadoc": "/**\n     * Appends this builder's new line string to this builder.\n     * <p>\n     * By default, the new line is the system default from {@link System#lineSeparator()}.\n     * </p>\n     * <p>\n     * The new line string can be changed using {@link #setNewLineText(String)}. For example, you can use this to force the output to always use Unix line\n     * endings even when on Windows.\n     * </p>\n     *\n     * @return this\n     * @see #getNewLineText()\n     * @see #setNewLineText(String)\n     */"
    },
    {
        "signature": "public TextStringBuilder appendNull()",
        "implementation": "public TextStringBuilder appendNull() {\n        if (nullText == null) {\n            return this;\n        }\n        return append(nullText);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendNull",
        "javadoc": "/**\n     * Appends the text representing {@code null} to this string builder.\n     *\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder appendPadding(final int length, final char padChar)",
        "implementation": "public TextStringBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacityInternal(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacityInternal"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendPadding",
        "javadoc": "/**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length the length to append, negative means no append\n     * @param padChar the character to append\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder appendSeparator(final String standard, final String defaultIfEmpty)",
        "implementation": "public TextStringBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }",
        "called_methods": [
            "isNotEmpty",
            "append",
            "isEmpty",
            "appendSeparator"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendSeparator",
        "javadoc": "/**\n     * Appends one of both separators to the StrBuilder. If the builder is currently empty, it will append the\n     * defaultIfEmpty-separator, otherwise it will append the standard-separator.\n     * <p>\n     * Appending a null separator will have no effect. The separator is appended using {@link #append(String)}.\n     * </p>\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     *\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if (searchCommand.getPriority() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" priority = ?\")\n     * }\n     * if (searchCommand.getComponent() != null) {\n     *  whereClause.appendSeparator(\" and\", \" where\");\n     *  whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public void appendTo(final Appendable appendable) throws IOException",
        "implementation": "public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendTo",
        "javadoc": "/**\n     * Appends current contents of this {@code StrBuilder} to the provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable the appendable to append data to\n     * @throws IOException if an I/O error occurs.\n     * @see #readFrom(Readable)\n     */"
    },
    {
        "signature": "private void appendTrue(int index)",
        "implementation": "private void appendTrue(int index) {\n        buffer[index++] = 't';\n        buffer[index++] = 'r';\n        buffer[index++] = 'u';\n        buffer[index] = 'e';\n        size += TRUE_STRING_SIZE;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendTrue",
        "javadoc": "/** Appends {@code \"true\"}. */"
    },
    {
        "signature": "public TextStringBuilder appendWithSeparators(final Object[] array, final String separator)",
        "implementation": "public TextStringBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "appendWithSeparators",
            "iterator",
            "toString",
            "hasNext",
            "append",
            "next"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "appendWithSeparators",
        "javadoc": "/**\n     * Appends an array placing separators between each value, but not before the first or after the last. Appending a\n     * null array will have no effect. Each object is appended using {@link #append(Object)}.\n     *\n     * @param array the array to append\n     * @param separator the separator to use, null means no separator\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public Reader asReader()",
        "implementation": "public Reader asReader() {\n        return new TextStringBuilderReader();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "asReader",
        "javadoc": "/**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader. This allows you to append to the\n     * builder after creating the reader, and the changes will be picked up. Note however, that no synchronization\n     * occurs, so you must perform all operations with the builder and the reader in one thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */"
    },
    {
        "signature": "public StringTokenizer asTokenizer()",
        "implementation": "public StringTokenizer asTokenizer() {\n        return new TextStringBuilderTokenizer();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "asTokenizer",
        "javadoc": "/**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized. The tokenizer will be setup by default to\n     * tokenize on space, tab, newline and form feed (as per StringTokenizer). These values can be changed on the\n     * tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix calls to the builder and tokenizer within\n     * certain limits, however there is no synchronization. Once the tokenizer has been used once, it must be\n     * {@link StringTokenizer#reset() reset} to pickup the latest changes in the builder. For example:\n     * </p>\n     *\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray(); // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray(); // returns a,b (c and d ignored)\n     * t.reset(); // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray(); // returns a,b,c,d\n     * </pre>\n     *\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also call the set methods on the tokenizer to\n     * alter how it tokenizes. Just remember to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StringTokenizer#reset(String)} or {@link StringTokenizer#reset(char[])} with a non-null value will\n     * break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */"
    },
    {
        "signature": "public Writer asWriter()",
        "implementation": "public Writer asWriter() {\n        return new TextStringBuilderWriter();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "asWriter",
        "javadoc": "/**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, call {@code asWriter}, and populate away. The data is available at\n     * any time using the methods of the {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer. This allows you to intermix calls that\n     * append to the builder and write using the writer and the changes will be occur correctly. Note however, that no\n     * synchronization occurs, so you must perform all operations with the builder and the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */"
    },
    {
        "signature": "public String build()",
        "implementation": "public String build() {\n        return toString();\n    }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "build",
        "javadoc": "/**\n     * Converts this instance to a String.\n     *\n     * @return This instance as a String\n     * @see #toString()\n     * @deprecated Use {@link #get()}.\n     */"
    },
    {
        "signature": "public int capacity()",
        "implementation": "public int capacity() {\n        return buffer.length;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "capacity",
        "javadoc": "/**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */"
    },
    {
        "signature": "public char charAt(final int index)",
        "implementation": "public char charAt(final int index) {\n        validateIndex(index);\n        return buffer[index];\n    }",
        "called_methods": [
            "validateIndex"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "charAt",
        "javadoc": "/**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public TextStringBuilder clear()",
        "implementation": "public TextStringBuilder clear() {\n        size = 0;\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "clear",
        "javadoc": "/**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer. To do that, call {@code clear()} followed\n     * by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero and is provided to match the API of\n     * Collections.\n     * </p>\n     *\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public boolean contains(final StringMatcher matcher)",
        "implementation": "public boolean contains(final StringMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }",
        "called_methods": [
            "indexOf"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "contains",
        "javadoc": "/**\n     * Tests if the string builder contains a string matched using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to search for\n     * the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */"
    },
    {
        "signature": "public TextStringBuilder delete(final int startIndex, final int endIndex)",
        "implementation": "public TextStringBuilder delete(final int startIndex, final int endIndex) {\n        final int actualEndIndex = validateRange(startIndex, endIndex);\n        final int len = actualEndIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, actualEndIndex, len);\n        }\n        return this;\n    }",
        "called_methods": [
            "validateRange",
            "deleteImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "delete",
        "javadoc": "/**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public TextStringBuilder deleteAll(final StringMatcher matcher)",
        "implementation": "public TextStringBuilder deleteAll(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }",
        "called_methods": [
            "deleteImpl",
            "length",
            "indexOf",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "deleteAll",
        "javadoc": "/**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder deleteCharAt(final int index)",
        "implementation": "public TextStringBuilder deleteCharAt(final int index) {\n        validateIndex(index);\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }",
        "called_methods": [
            "validateIndex",
            "deleteImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "deleteCharAt",
        "javadoc": "/**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public TextStringBuilder deleteFirst(final StringMatcher matcher)",
        "implementation": "public TextStringBuilder deleteFirst(final StringMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }",
        "called_methods": [
            "deleteImpl",
            "length",
            "indexOf",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "deleteFirst",
        "javadoc": "/**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "private void deleteImpl(final int startIndex, final int endIndex, final int len)",
        "implementation": "private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }",
        "called_methods": [
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "deleteImpl",
        "javadoc": "/**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex the end index (exclusive), must be valid\n     * @param len the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */"
    },
    {
        "signature": "public char drainChar(final int index)",
        "implementation": "public char drainChar(final int index) {\n        validateIndex(index);\n        final char c = buffer[index];\n        deleteCharAt(index);\n        return c;\n    }",
        "called_methods": [
            "validateIndex",
            "deleteCharAt"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "drainChar",
        "javadoc": "/**\n     * Gets the character at the specified index before deleting it.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 1.9\n     */"
    },
    {
        "signature": "public int drainChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex)",
        "implementation": "public int drainChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        final int length = endIndex - startIndex;\n        if (isEmpty() || length == 0 || target.length == 0) {\n            return 0;\n        }\n        final int actualLen = Math.min(Math.min(size, length), target.length - targetIndex);\n        getChars(startIndex, actualLen, target, targetIndex);\n        delete(startIndex, actualLen);\n        return actualLen;\n    }",
        "called_methods": [
            "isEmpty",
            "min",
            "getChars",
            "delete"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "drainChars",
        "javadoc": "/**\n     * Drains (copies, then deletes) this character sequence into the specified array. This is equivalent to copying the\n     * characters from this sequence into the target and then deleting those character from this sequence.\n     *\n     * @param startIndex first index to copy, inclusive.\n     * @param endIndex last index to copy, exclusive.\n     * @param target the target array, must not be {@code null}.\n     * @param targetIndex the index to start copying in the target.\n     * @return How many characters where copied (then deleted). If this builder is empty, return {@code 0}.\n     * @since 1.9\n     */"
    },
    {
        "signature": "public boolean endsWith(final String str)",
        "implementation": "public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "length",
            "charAt"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "endsWith",
        "javadoc": "/**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */"
    },
    {
        "signature": "public TextStringBuilder ensureCapacity(final int capacity)",
        "implementation": "public TextStringBuilder ensureCapacity(final int capacity) {\n        if (capacity > 0) {\n            ensureCapacityInternal(capacity);\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacityInternal"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "ensureCapacity",
        "javadoc": "/**\n     * Tests the capacity and ensures that it is at least the size specified.\n     *\n     * <p>\n     * Note: This method can be used to minimise memory reallocations during\n     * repeated addition of values by pre-allocating the character buffer.\n     * The method ignores a negative {@code capacity} argument.\n     * </p>\n     *\n     * @param capacity the capacity to ensure\n     * @return this, to enable chaining\n     * @throws OutOfMemoryError if the capacity cannot be allocated\n     */"
    },
    {
        "signature": "private void ensureCapacityInternal(final int capacity)",
        "implementation": "private void ensureCapacityInternal(final int capacity) {\n        // Check for overflow of the current buffer.\n        // Assumes capacity is an unsigned integer up to Integer.MAX_VALUE * 2\n        // (the largest possible addition of two maximum length arrays).\n        if (capacity - buffer.length > 0) {\n            resizeBuffer(capacity);\n        }\n    }",
        "called_methods": [
            "resizeBuffer"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "ensureCapacityInternal",
        "javadoc": "/**\n     * Ensures that the buffer is at least the size specified. The {@code capacity} argument\n     * is treated as an unsigned integer.\n     *\n     * <p>\n     * This method will raise an {@link OutOfMemoryError} if the capacity is too large\n     * for an array, or cannot be allocated.\n     * </p>\n     *\n     * @param capacity the capacity to ensure\n     * @throws OutOfMemoryError if the capacity cannot be allocated\n     */"
    },
    {
        "signature": "public boolean equals(final TextStringBuilder other)",
        "implementation": "public boolean equals(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        // Be aware not to use Arrays.equals(buffer, other.buffer) for equals() method\n        // as length of the buffers may be different (TEXT-211)\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "equals"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "equals",
        "javadoc": "/**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */"
    },
    {
        "signature": "public boolean equalsIgnoreCase(final TextStringBuilder other)",
        "implementation": "public boolean equalsIgnoreCase(final TextStringBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "toUpperCase"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "equalsIgnoreCase",
        "javadoc": "/**\n     * Tests the contents of this builder against another to see if they contain the same character content ignoring\n     * case.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */"
    },
    {
        "signature": "public String get()",
        "implementation": "public String get() {\n        return toString();\n    }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "get",
        "javadoc": "/**\n     * Converts this instance to a String.\n     *\n     * @return This instance as a String\n     * @see #toString()\n     * @since 1.12.0\n     */"
    },
    {
        "signature": "char[] getBuffer()",
        "implementation": "char[] getBuffer() {\n        return buffer;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "getBuffer",
        "javadoc": "/**\n     * Gets a direct reference to internal storage, not for public consumption.\n     */"
    },
    {
        "signature": "public void getChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex)",
        "implementation": "public void getChars(final int startIndex, final int endIndex, final char[] target, final int targetIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, target, targetIndex, endIndex - startIndex);\n    }",
        "called_methods": [
            "length",
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "getChars",
        "javadoc": "/**\n     * Copies this character array into the specified array.\n     *\n     * @param startIndex first index to copy, inclusive, must be valid.\n     * @param endIndex last index to copy, exclusive, must be valid.\n     * @param target the target array, must not be null or too small.\n     * @param targetIndex the index to start copying in target.\n     * @throws NullPointerException if the array is null.\n     * @throws IndexOutOfBoundsException if any index is invalid.\n     */"
    },
    {
        "signature": "public String getNewLineText()",
        "implementation": "public String getNewLineText() {\n        return newLine;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "getNewLineText",
        "javadoc": "/**\n     * Gets the text to be appended when a {@link #appendNewLine() new line} is added.\n     *\n     * @return The new line text, {@code null} means use the system default from {@link System#lineSeparator()}.\n     */"
    },
    {
        "signature": "public String getNullText()",
        "implementation": "public String getNullText() {\n        return nullText;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "getNullText",
        "javadoc": "/**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */"
    },
    {
        "signature": "public int hashCode()",
        "implementation": "public int hashCode() {\n        // no allocation\n        final char[] buf = buffer;\n        int result = 0;\n        for (int i = 0; i < size; i++) {\n            result = 31 * result + buf[i];\n        }\n        return result;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "hashCode",
        "javadoc": "/**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */"
    },
    {
        "signature": "public int indexOf(final StringMatcher matcher, int startIndex)",
        "implementation": "public int indexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = Math.max(0, startIndex);\n        if (matcher == null || startIndex >= size) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }",
        "called_methods": [
            "indexOf",
            "max",
            "length",
            "charAt",
            "isMatch"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "indexOf",
        "javadoc": "/**\n     * Searches the string builder using the matcher to find the first match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */"
    },
    {
        "signature": "public TextStringBuilder insert(final int index, String str)",
        "implementation": "public TextStringBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacityInternal(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "validateIndex",
            "ensureCapacityInternal",
            "arraycopy",
            "appendTrue",
            "appendFalse",
            "insert",
            "valueOf",
            "toString",
            "length",
            "getChars"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "insert",
        "javadoc": "/**\n     * Inserts the string into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param str the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public boolean isEmpty()",
        "implementation": "public boolean isEmpty() {\n        return size == 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "isEmpty",
        "javadoc": "/**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */"
    },
    {
        "signature": "public boolean isNotEmpty()",
        "implementation": "public boolean isNotEmpty() {\n        return size != 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "isNotEmpty",
        "javadoc": "/**\n     * Checks is the string builder is not empty.\n     * <p>\n     * This method is the same as checking {@link #length()}.\n     * </p>\n     *\n     * @return {@code true} if the size is not {@code 0}.\n     * @since 1.9\n     */"
    },
    {
        "signature": "public boolean isReallocated()",
        "implementation": "public boolean isReallocated() {\n        return reallocations > 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "isReallocated",
        "javadoc": "/**\n     * Gets whether the internal buffer has been reallocated.\n     *\n     * @return Whether the internal buffer has been reallocated.\n     * @since 1.9\n     */"
    },
    {
        "signature": "public int lastIndexOf(final StringMatcher matcher, int startIndex)",
        "implementation": "public int lastIndexOf(final StringMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return StringUtils.INDEX_NOT_FOUND;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return StringUtils.INDEX_NOT_FOUND;\n    }",
        "called_methods": [
            "lastIndexOf",
            "length",
            "charAt",
            "isMatch"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "lastIndexOf",
        "javadoc": "/**\n     * Searches the string builder using the matcher to find the last match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the\n     * character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */"
    },
    {
        "signature": "public String leftString(final int length)",
        "implementation": "public String leftString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, 0, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "leftString",
        "javadoc": "/**\n     * Extracts the leftmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public int length()",
        "implementation": "public int length() {\n        return size;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "length",
        "javadoc": "/**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */"
    },
    {
        "signature": "public String midString(int index, final int length)",
        "implementation": "public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return StringUtils.EMPTY;\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "midString",
        "javadoc": "/**\n     * Extracts some characters from the middle of the string builder without throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder at the specified index. If the index is negative\n     * it is treated as zero. If the index is greater than the builder size, it is treated as the builder size. If the\n     * length is negative, the empty string is returned. If insufficient characters are available in the builder, as\n     * much as possible is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index the index to start at, negative means zero\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public TextStringBuilder minimizeCapacity()",
        "implementation": "public TextStringBuilder minimizeCapacity() {\n        if (buffer.length > size) {\n            reallocate(size);\n        }\n        return this;\n    }",
        "called_methods": [
            "reallocate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "minimizeCapacity",
        "javadoc": "/**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public int readFrom(final Reader reader, final int count) throws IOException",
        "implementation": "public int readFrom(final Reader reader, final int count) throws IOException {\n        if (count <= 0) {\n            return 0;\n        }\n        final int oldSize = size;\n        ensureCapacityInternal(size + count);\n        int target = count;\n        int readCount = reader.read(buffer, size, target);\n        if (readCount == EOS) {\n            return EOS;\n        }\n        do {\n            target -= readCount;\n            size += readCount;\n            readCount = reader.read(buffer, size, target);\n        } while (target > 0 && readCount != EOS);\n        return size - oldSize;\n    }",
        "called_methods": [
            "remaining",
            "ensureCapacityInternal",
            "get",
            "readFrom",
            "wrap",
            "read"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "readFrom",
        "javadoc": "/**\n     * If possible, reads {@code count} chars from the provided {@link Reader} directly into underlying character buffer\n     * without making extra copies.\n     *\n     * @param reader Reader to read.\n     * @param count The maximum characters to read, a value &lt;= 0 returns 0.\n     * @return The number of characters read. If less than {@code count}, then we've reached the end-of-stream, or -1 if\n     *         we reached the end of stream.\n     * @throws IOException if an I/O error occurs.\n     * @see #appendTo(Appendable)\n     * @since 1.9\n     */"
    },
    {
        "signature": "private void reallocate(final int newLength)",
        "implementation": "private void reallocate(final int newLength) {\n        this.buffer = Arrays.copyOf(buffer, newLength);\n        this.reallocations++;\n    }",
        "called_methods": [
            "copyOf"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "reallocate",
        "javadoc": "/**\n     * Reallocates the buffer to the new length.\n     *\n     * @param newLength the length of the copy to be returned\n     */"
    },
    {
        "signature": "public TextStringBuilder replace(final StringMatcher matcher, final String replaceStr, final int startIndex,\n        int endIndex, final int replaceCount)",
        "implementation": "public TextStringBuilder replace(final StringMatcher matcher, final String replaceStr, final int startIndex,\n        int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }",
        "called_methods": [
            "validateRange",
            "length",
            "replaceImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "replace",
        "javadoc": "/**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */"
    },
    {
        "signature": "public TextStringBuilder replaceAll(final StringMatcher matcher, final String replaceStr)",
        "implementation": "public TextStringBuilder replaceAll(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }",
        "called_methods": [
            "length",
            "indexOf",
            "replaceImpl",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "replaceAll",
        "javadoc": "/**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public TextStringBuilder replaceFirst(final StringMatcher matcher, final String replaceStr)",
        "implementation": "public TextStringBuilder replaceFirst(final StringMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }",
        "called_methods": [
            "length",
            "indexOf",
            "replaceImpl",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "replaceFirst",
        "javadoc": "/**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace where\n     * the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "private TextStringBuilder replaceImpl(final StringMatcher matcher, final String replaceStr, final int from, int to,\n        int replaceCount)",
        "implementation": "private TextStringBuilder replaceImpl(final StringMatcher matcher, final String replaceStr, final int from, int to,\n        int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacityInternal",
            "arraycopy",
            "getChars",
            "length",
            "isMatch",
            "replaceImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "replaceImpl",
        "javadoc": "/**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all\n     * occurrences where the character 'a' is followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the string to replace the match with, null is a delete\n     * @param from the start index, must be valid\n     * @param to the end index (exclusive), must be valid\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */"
    },
    {
        "signature": "private void resizeBuffer(final int minCapacity)",
        "implementation": "private void resizeBuffer(final int minCapacity) {\n        // Overflow-conscious code treats the min and new capacity as unsigned.\n        final int oldCapacity = buffer.length;\n        int newCapacity = oldCapacity * 2;\n        if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) {\n            newCapacity = minCapacity;\n        }\n        if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) {\n            newCapacity = createPositiveCapacity(minCapacity);\n        }\n        reallocate(newCapacity);\n    }",
        "called_methods": [
            "compareUnsigned",
            "createPositiveCapacity",
            "reallocate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "resizeBuffer",
        "javadoc": "/**\n     * Resizes the buffer to at least the size specified.\n     *\n     * @param minCapacity the minimum required capacity\n     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n     */"
    },
    {
        "signature": "public TextStringBuilder reverse()",
        "implementation": "public TextStringBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "reverse",
        "javadoc": "/**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public String rightString(final int length)",
        "implementation": "public String rightString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, size - length, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "rightString",
        "javadoc": "/**\n     * Extracts the rightmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from the builder. If this many characters are not\n     * available, the whole builder is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public TextStringBuilder set(final CharSequence str)",
        "implementation": "public TextStringBuilder set(final CharSequence str) {\n        clear();\n        append(str);\n        return this;\n    }",
        "called_methods": [
            "clear",
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "set",
        "javadoc": "/**\n     * Clears and sets this builder to the given value.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param str the new value.\n     * @return this, to enable chaining\n     * @since 1.9\n     */"
    },
    {
        "signature": "public TextStringBuilder setCharAt(final int index, final char ch)",
        "implementation": "public TextStringBuilder setCharAt(final int index, final char ch) {\n        validateIndex(index);\n        buffer[index] = ch;\n        return this;\n    }",
        "called_methods": [
            "validateIndex"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "setCharAt",
        "javadoc": "/**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to set\n     * @param ch the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public TextStringBuilder setLength(final int length)",
        "implementation": "public TextStringBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacityInternal(length);\n            final int oldEnd = size;\n            size = length;\n            Arrays.fill(buffer, oldEnd, length, '\\0');\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacityInternal",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "setLength",
        "javadoc": "/**\n     * Updates the length of the builder by either dropping the last characters or adding filler of Unicode zero.\n     *\n     * @param length the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */"
    },
    {
        "signature": "public TextStringBuilder setNewLineText(final String newLine)",
        "implementation": "public TextStringBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "setNewLineText",
        "javadoc": "/**\n     * Sets the text to be appended when {@link #appendNewLine() new line} is called.\n     *\n     * @param newLine the new line text, {@code null} means use the system default from {@link System#lineSeparator()}.\n     * @return this instance.\n     */"
    },
    {
        "signature": "public TextStringBuilder setNullText(String nullText)",
        "implementation": "public TextStringBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }",
        "called_methods": [
            "isEmpty"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "setNullText",
        "javadoc": "/**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText the null text, null means no append\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public int size()",
        "implementation": "public int size() {\n        return size;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "size",
        "javadoc": "/**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return The length\n     */"
    },
    {
        "signature": "public boolean startsWith(final String str)",
        "implementation": "public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "length",
            "charAt"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "startsWith",
        "javadoc": "/**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */"
    },
    {
        "signature": "public CharSequence subSequence(final int startIndex, final int endIndex)",
        "implementation": "public CharSequence subSequence(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n        }\n        return substring(startIndex, endIndex);\n    }",
        "called_methods": [
            "substring"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "subSequence",
        "javadoc": "/**\n     * {@inheritDoc}\n     */"
    },
    {
        "signature": "public String substring(final int startIndex, int endIndex)",
        "implementation": "public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }",
        "called_methods": [
            "substring",
            "validateRange"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "substring",
        "javadoc": "/**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the builder as equal to the length of the\n     * builder, and continues without error, unlike StringBuffer or String.\n     * </p>\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public char[] toCharArray(final int startIndex, int endIndex)",
        "implementation": "public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        return len == 0 ? ArrayUtils.EMPTY_CHAR_ARRAY : Arrays.copyOfRange(buffer, startIndex, endIndex);\n    }",
        "called_methods": [
            "copyOf",
            "validateRange",
            "copyOfRange"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "toCharArray",
        "javadoc": "/**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid, or if endIndex is invalid (but endIndex greater than\n     *         size is valid)\n     */"
    },
    {
        "signature": "public StringBuffer toStringBuffer()",
        "implementation": "public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "toStringBuffer",
        "javadoc": "/**\n     * Gets a StringBuffer version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */"
    },
    {
        "signature": "public StringBuilder toStringBuilder()",
        "implementation": "public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "toStringBuilder",
        "javadoc": "/**\n     * Gets a StringBuilder version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */"
    },
    {
        "signature": "public TextStringBuilder trim()",
        "implementation": "public TextStringBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= SPACE) {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= SPACE) {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }",
        "called_methods": [
            "delete"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "trim",
        "javadoc": "/**\n     * Trims the builder by removing characters less than or equal to a space from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "protected void validateIndex(final int index)",
        "implementation": "protected void validateIndex(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "validateIndex",
        "javadoc": "/**\n     * Validates that an index is in the range {@code 0 <= index <= size}.\n     *\n     * @param index the index to test.\n     * @throws IndexOutOfBoundsException Thrown when the index is not the range {@code 0 <= index <= size}.\n     */"
    },
    {
        "signature": "protected int validateRange(final int startIndex, int endIndex)",
        "implementation": "protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\TextStringBuilder.java",
        "name": "validateRange",
        "javadoc": "/**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return A valid end index.\n     * @throws StringIndexOutOfBoundsException if the index is invalid\n     */"
    }
]