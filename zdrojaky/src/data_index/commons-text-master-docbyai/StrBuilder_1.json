[
    {
        "signature": "public void close()",
        "implementation": "public void close() {\n            // do nothing\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "close",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void mark(final int readAheadLimit)",
        "implementation": "public void mark(final int readAheadLimit) {\n            mark = pos;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "mark",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public boolean markSupported()",
        "implementation": "public boolean markSupported() {\n            return true;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "markSupported",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public int read(final char[] b, final int off, int len)",
        "implementation": "public int read(final char[] b, final int off, int len) {\n            if (off < 0 || len < 0 || off > b.length || off + len > b.length || off + len < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }",
        "called_methods": [
            "ready",
            "charAt",
            "size",
            "getChars"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "read",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public boolean ready()",
        "implementation": "public boolean ready() {\n            return pos < size();\n        }",
        "called_methods": [
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "ready",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void reset()",
        "implementation": "public void reset() {\n            pos = mark;\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "reset",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public long skip(long n)",
        "implementation": "public long skip(long n) {\n            if (pos + n > size()) {\n                n = size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos = Math.addExact(pos, Math.toIntExact(n));\n            return n;\n        }",
        "called_methods": [
            "size",
            "addExact",
            "toIntExact"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "skip",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public String getContent()",
        "implementation": "public String getContent() {\n            final String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            }\n            return str;\n        }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "getContent",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "protected List<String> tokenize(final char[] chars, final int offset, final int count)",
        "implementation": "protected List<String> tokenize(final char[] chars, final int offset, final int count) {\n            if (chars == null) {\n                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            }\n            return super.tokenize(chars, offset, count);\n        }",
        "called_methods": [
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "tokenize",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void flush()",
        "implementation": "public void flush() {\n            // do nothing\n        }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "flush",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public void write(final String str, final int off, final int len)",
        "implementation": "public void write(final String str, final int off, final int len) {\n            StrBuilder.this.append(str, off, len);\n        }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "write",
        "javadoc": "/** {@inheritDoc} */"
    },
    {
        "signature": "public StrBuilder append(final StringBuilder str, final int startIndex, final int length)",
        "implementation": "public StrBuilder append(final StringBuilder str, final int startIndex, final int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || startIndex + length > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            final int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacity",
            "length",
            "appendNull",
            "arraycopy",
            "hasArray",
            "remaining",
            "array",
            "arrayOffset",
            "position",
            "append",
            "toString",
            "valueOf",
            "getChars",
            "format"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "append",
        "javadoc": "/**\n     * Appends part of a StringBuilder to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str        the StringBuilder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length     the length to append, must be valid\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "* fine, because it isn't inherited by subclasses, so each subclass must vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0)",
        "implementation": "public <T> StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array) {\n        /*\n         * @SuppressWarnings used to hide warning about vararg usage. We cannot use @SafeVarargs, since this method is not final. Using @SuppressWarnings is\n         * fine, because it isn't inherited by subclasses, so each subclass must vouch for itself whether its use of 'array' is safe.\n         */\n        if (array != null && array.length > 0) {\n            for (final Object element : array) {\n                append(element);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "forEach",
            "hasNext",
            "append",
            "next"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendAll",
        "javadoc": "/**\n     * Appends each item in an array to the builder without any separators. Appending a null array will have no effect. Each object is appended using\n     * {@link #append(Object)}.\n     *\n     * @param <T>   the element type\n     * @param array the array to append\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar)",
        "implementation": "public StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = Objects.toString(obj, getNullText());\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                final int toIndex = size + padLen;\n                Arrays.fill(buffer, size, toIndex, padChar);\n                str.getChars(0, strLen, buffer, toIndex);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "called_methods": [
            "appendFixedWidthPadLeft",
            "valueOf",
            "ensureCapacity",
            "toString",
            "getNullText",
            "length",
            "getChars",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendFixedWidthPadLeft",
        "javadoc": "/**\n     * Appends an object to the builder padding on the left to a fixed width. The {@code toString} of the object is used. If the object is larger than the\n     * length, the left hand side is lost. If the object is null, the null text value is used.\n     *\n     * @param obj     the object to append, null uses null text\n     * @param width   the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)",
        "implementation": "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = Objects.toString(obj, getNullText());\n            if (str == null) {\n                str = StringUtils.EMPTY;\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                str.getChars(0, strLen, buffer, size);\n                final int fromIndex = size + strLen;\n                Arrays.fill(buffer, fromIndex, fromIndex + width - strLen, padChar);\n            }\n            size += width;\n        }\n        return this;\n    }",
        "called_methods": [
            "appendFixedWidthPadRight",
            "valueOf",
            "ensureCapacity",
            "toString",
            "getNullText",
            "length",
            "getChars",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendFixedWidthPadRight",
        "javadoc": "/**\n     * Appends an object to the builder padding on the right to a fixed length. The {@code toString} of the object is used. If the object is larger than the\n     * length, the right hand side is lost. If the object is null, null text value is used.\n     *\n     * @param obj     the object to append, null uses null text\n     * @param width   the fixed field width, zero or negative has no effect\n     * @param padChar the pad character to use\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length)",
        "implementation": "public StrBuilder appendln(final StringBuilder str, final int startIndex, final int length) {\n        return append(str, startIndex, length).appendNewLine();\n    }",
        "called_methods": [
            "append",
            "appendNewLine"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendln",
        "javadoc": "/**\n     * Appends part of a string builder followed by a {@link #appendNewLine() new line} to this string builder. Appending null will call {@link #appendNull()}.\n     *\n     * @param str        the string builder to append\n     * @param startIndex the start index, inclusive, must be valid\n     * @param length     the length to append, must be valid\n     * @return {@code this} instance.\n     * @see #appendNewLine()\n     */"
    },
    {
        "signature": "public StrBuilder appendNewLine()",
        "implementation": "public StrBuilder appendNewLine() {\n        if (newLine == null) {\n            append(System.lineSeparator());\n            return this;\n        }\n        return append(newLine);\n    }",
        "called_methods": [
            "append",
            "lineSeparator"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendNewLine",
        "javadoc": "/**\n     * Appends this builder's new line string to this builder.\n     * <p>\n     * By default, the new line is the system default from {@link System#lineSeparator()}.\n     * </p>\n     * <p>\n     * The new line string can be changed using {@link #setNewLineText(String)}. For example, you can use this to force the output to always use Unix line\n     * endings even when on Windows.\n     * </p>\n     *\n     * @return {@code this} instance.\n     * @see #getNewLineText()\n     * @see #setNewLineText(String)\n     */"
    },
    {
        "signature": "public StrBuilder appendNull()",
        "implementation": "public StrBuilder appendNull() {\n        if (nullText == null) {\n            return this;\n        }\n        return append(nullText);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendNull",
        "javadoc": "/**\n     * Appends this builder's null text to this builder.\n     *\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder appendPadding(final int length, final char padChar)",
        "implementation": "public StrBuilder appendPadding(final int length, final char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacity"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendPadding",
        "javadoc": "/**\n     * Appends the pad character to the builder the specified number of times.\n     *\n     * @param length  the length to append, negative means no append\n     * @param padChar the character to append\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty)",
        "implementation": "public StrBuilder appendSeparator(final String standard, final String defaultIfEmpty) {\n        final String str = isEmpty() ? defaultIfEmpty : standard;\n        if (str != null) {\n            append(str);\n        }\n        return this;\n    }",
        "called_methods": [
            "isNotEmpty",
            "append",
            "appendSeparator",
            "isEmpty"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendSeparator",
        "javadoc": "/**\n     * Appends one of both separators to the StrBuilder. If the builder is currently empty it will append the defaultIfEmpty-separator Otherwise it will append\n     * the standard-separator\n     * <p>\n     * Appending a null separator will have no effect. The separator is appended using {@link #append(String)}.\n     * </p>\n     * <p>\n     * This method is for example useful for constructing queries\n     * </p>\n     *\n     * <pre>\n     * StrBuilder whereClause = new StrBuilder();\n     * if (searchCommand.getPriority() != null) {\n     *   whereClause.appendSeparator(\" and\", \" where\");\n     *   whereClause.append(\" priority = ?\")\n     * }\n     * if (searchCommand.getComponent() != null) {\n     *   whereClause.appendSeparator(\" and\", \" where\");\n     *   whereClause.append(\" component = ?\")\n     * }\n     * selectClause.append(whereClause)\n     * </pre>\n     *\n     * @param standard       the separator if builder is not empty, null means no separator\n     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public void appendTo(final Appendable appendable) throws IOException",
        "implementation": "public void appendTo(final Appendable appendable) throws IOException {\n        if (appendable instanceof Writer) {\n            ((Writer) appendable).write(buffer, 0, size);\n        } else if (appendable instanceof StringBuilder) {\n            ((StringBuilder) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof StringBuffer) {\n            ((StringBuffer) appendable).append(buffer, 0, size);\n        } else if (appendable instanceof CharBuffer) {\n            ((CharBuffer) appendable).put(buffer, 0, size);\n        } else {\n            appendable.append(this);\n        }\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendTo",
        "javadoc": "/**\n     * Appends current contents of this {@code StrBuilder} to the provided {@link Appendable}.\n     * <p>\n     * This method tries to avoid doing any extra copies of contents.\n     * </p>\n     *\n     * @param appendable the appendable to append data to\n     * @throws IOException if an I/O error occurs\n     * @see #readFrom(Readable)\n     */"
    },
    {
        "signature": "public StrBuilder appendWithSeparators(final Object[] array, final String separator)",
        "implementation": "public StrBuilder appendWithSeparators(final Object[] array, final String separator) {\n        if (array != null && array.length > 0) {\n            final String sep = Objects.toString(separator, StringUtils.EMPTY);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(sep);\n                append(array[i]);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "appendWithSeparators",
            "iterator",
            "toString",
            "hasNext",
            "append",
            "next"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "appendWithSeparators",
        "javadoc": "/**\n     * Appends an array placing separators between each value, but not before the first or after the last. Appending a null array will have no effect. Each\n     * object is appended using {@link #append(Object)}.\n     *\n     * @param array     the array to append\n     * @param separator the separator to use, null means no separator\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public Reader asReader()",
        "implementation": "public Reader asReader() {\n        return new StrBuilderReader();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "asReader",
        "javadoc": "/**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read using any standard method that expects a Reader.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, populate it with data, call {@code asReader}, and then read away.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the reader. This allows you to append to the builder after creating the reader, and the\n     * changes will be picked up. Note however, that no synchronization occurs, so you must perform all operations with the builder and the reader in one\n     * thread.\n     * </p>\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     * </p>\n     *\n     * @return a reader that reads from this builder\n     */"
    },
    {
        "signature": "public StrTokenizer asTokenizer()",
        "implementation": "public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "asTokenizer",
        "javadoc": "/**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized. The tokenizer will be setup by default to tokenize on space, tab, newline and form feed\n     * (as per StringTokenizer). These values can be changed on the tokenizer class, before retrieving the tokens.\n     * </p>\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix calls to the builder and tokenizer within certain limits, however there is no\n     * synchronization. Once the tokenizer has been used once, it must be {@link StrTokenizer#reset() reset} to pickup the latest changes in the builder. For\n     * example:\n     * </p>\n     *\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray(); // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray(); // returns a,b (c and d ignored)\n     * t.reset(); // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray(); // returns a,b,c,d\n     * </pre>\n     * <p>\n     * In addition to simply intermixing appends and tokenization, you can also call the set methods on the tokenizer to alter how it tokenizes. Just remember\n     * to call reset when you want to pickup builder changes.\n     * </p>\n     * <p>\n     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])} with a non-null value will break the link with the builder.\n     * </p>\n     *\n     * @return a tokenizer that is linked to this builder\n     */"
    },
    {
        "signature": "public Writer asWriter()",
        "implementation": "public Writer asWriter() {\n        return new StrBuilderWriter();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "asWriter",
        "javadoc": "/**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder using any standard method that takes a Writer.\n     * </p>\n     * <p>\n     * To use, simply create a {@code StrBuilder}, call {@code asWriter}, and populate away. The data is available at any time using the methods of the\n     * {@code StrBuilder}.\n     * </p>\n     * <p>\n     * The internal character array is shared between the builder and the writer. This allows you to intermix calls that append to the builder and write using\n     * the writer and the changes will be occur correctly. Note however, that no synchronization occurs, so you must perform all operations with the builder and\n     * the writer in one thread.\n     * </p>\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     * </p>\n     *\n     * @return a writer that populates this builder\n     */"
    },
    {
        "signature": "public String build()",
        "implementation": "public String build() {\n        return toString();\n    }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "build",
        "javadoc": "/**\n     * Converts this instance to a String.\n     *\n     * @return This instance as a String\n     * @see #toString()\n     * @deprecated Use {@link #get()}.\n     */"
    },
    {
        "signature": "public int capacity()",
        "implementation": "public int capacity() {\n        return buffer.length;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "capacity",
        "javadoc": "/**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return The capacity\n     */"
    },
    {
        "signature": "public char charAt(final int index)",
        "implementation": "public char charAt(final int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }",
        "called_methods": [
            "length"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "charAt",
        "javadoc": "/**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index the index to retrieve, must be valid\n     * @return The character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder clear()",
        "implementation": "public StrBuilder clear() {\n        size = 0;\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "clear",
        "javadoc": "/**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer. To do that, call {@code clear()} followed by {@link #minimizeCapacity()}.\n     * </p>\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public boolean contains(final StrMatcher matcher)",
        "implementation": "public boolean contains(final StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }",
        "called_methods": [
            "indexOf"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "contains",
        "javadoc": "/**\n     * Tests if the string builder contains a string matched using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to search for the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */"
    },
    {
        "signature": "public StrBuilder delete(final int startIndex, int endIndex)",
        "implementation": "public StrBuilder delete(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }",
        "called_methods": [
            "validateRange",
            "deleteImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "delete",
        "javadoc": "/**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex   the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder deleteAll(final StrMatcher matcher)",
        "implementation": "public StrBuilder deleteAll(final StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }",
        "called_methods": [
            "deleteImpl",
            "length",
            "indexOf",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "deleteAll",
        "javadoc": "/**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete all occurrences where the character 'a' is\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder deleteCharAt(final int index)",
        "implementation": "public StrBuilder deleteCharAt(final int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }",
        "called_methods": [
            "deleteImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "deleteCharAt",
        "javadoc": "/**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index the index to delete\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder deleteFirst(final StrMatcher matcher)",
        "implementation": "public StrBuilder deleteFirst(final StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }",
        "called_methods": [
            "deleteImpl",
            "length",
            "indexOf",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "deleteFirst",
        "javadoc": "/**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behavior. For example you could write a matcher to delete where the character 'a' is followed by a\n     * number.\n     * </p>\n     *\n     * @param matcher the matcher to use to find the deletion, null causes no action\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "private void deleteImpl(final int startIndex, final int endIndex, final int len)",
        "implementation": "private void deleteImpl(final int startIndex, final int endIndex, final int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }",
        "called_methods": [
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "deleteImpl",
        "javadoc": "/**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex the start index, must be valid\n     * @param endIndex   the end index (exclusive), must be valid\n     * @param len        the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */"
    },
    {
        "signature": "public boolean endsWith(final String str)",
        "implementation": "public boolean endsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++, pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "length",
            "charAt"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "endsWith",
        "javadoc": "/**\n     * Tests whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */"
    },
    {
        "signature": "public StrBuilder ensureCapacity(final int capacity)",
        "implementation": "public StrBuilder ensureCapacity(final int capacity) {\n        if (capacity > buffer.length) {\n            final char[] old = buffer;\n            buffer = new char[capacity * 2];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }",
        "called_methods": [
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "ensureCapacity",
        "javadoc": "/**\n     * Tests the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity the capacity to ensure\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public boolean equals(final StrBuilder other)",
        "implementation": "public boolean equals(final StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (other == null) {\n            return false;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "equals"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "equals",
        "javadoc": "/**\n     * Tests the contents of this builder against another to see if they contain the same character content.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */"
    },
    {
        "signature": "public boolean equalsIgnoreCase(final StrBuilder other)",
        "implementation": "public boolean equalsIgnoreCase(final StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        final char[] thisBuf = this.buffer;\n        final char[] otherBuf = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            final char c1 = thisBuf[i];\n            final char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "toUpperCase"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "equalsIgnoreCase",
        "javadoc": "/**\n     * Tests the contents of this builder against another to see if they contain the same character content ignoring case.\n     *\n     * @param other the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */"
    },
    {
        "signature": "public String get()",
        "implementation": "public String get() {\n        return toString();\n    }",
        "called_methods": [
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "get",
        "javadoc": "/**\n     * Converts this instance to a String.\n     *\n     * @return This instance as a String\n     * @see #toString()\n     * @since 1.12.0\n     */"
    },
    {
        "signature": "public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex)",
        "implementation": "public void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }",
        "called_methods": [
            "length",
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "getChars",
        "javadoc": "/**\n     * Copies the character array into the specified array.\n     *\n     * @param startIndex       first index to copy, inclusive, must be valid\n     * @param endIndex         last index, exclusive, must be valid\n     * @param destination      the destination array, must not be null or too small\n     * @param destinationIndex the index to start copying in destination\n     * @throws NullPointerException      if the array is null\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */"
    },
    {
        "signature": "public String getNewLineText()",
        "implementation": "public String getNewLineText() {\n        return newLine;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "getNewLineText",
        "javadoc": "/**\n     * Gets the text to be appended when a {@link #appendNewLine() new line} is added.\n     *\n     * @return The new line text, {@code null} means use the system default from {@link System#lineSeparator()}.\n     */"
    },
    {
        "signature": "public String getNullText()",
        "implementation": "public String getNullText() {\n        return nullText;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "getNullText",
        "javadoc": "/**\n     * Gets the text to be appended when null is added.\n     *\n     * @return The null text, null means no append\n     */"
    },
    {
        "signature": "public int hashCode()",
        "implementation": "public int hashCode() {\n        final char[] buf = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "hashCode",
        "javadoc": "/**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */"
    },
    {
        "signature": "public int indexOf(final StrMatcher matcher, int startIndex)",
        "implementation": "public int indexOf(final StrMatcher matcher, int startIndex) {\n        startIndex = Math.max(startIndex, 0);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "called_methods": [
            "indexOf",
            "max",
            "length",
            "charAt",
            "isMatch"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "indexOf",
        "javadoc": "/**\n     * Searches the string builder using the matcher to find the first match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher    the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The first index matched, or -1 if not found\n     */"
    },
    {
        "signature": "public StrBuilder insert(final int index, String str)",
        "implementation": "public StrBuilder insert(final int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        if (str != null) {\n            final int strLen = str.length();\n            if (strLen > 0) {\n                final int newSize = size + strLen;\n                ensureCapacity(newSize);\n                System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                size = newSize;\n                str.getChars(0, strLen, buffer, index);\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "validateIndex",
            "ensureCapacity",
            "arraycopy",
            "insert",
            "valueOf",
            "toString",
            "length",
            "getChars"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "insert",
        "javadoc": "/**\n     * Inserts the string into this builder. Inserting null will use the stored null text value.\n     *\n     * @param index the index to add at, must be valid\n     * @param str   the string to insert\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public boolean isEmpty()",
        "implementation": "public boolean isEmpty() {\n        return size == 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "isEmpty",
        "javadoc": "/**\n     * Tests if the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is {@code 0}.\n     */"
    },
    {
        "signature": "public boolean isNotEmpty()",
        "implementation": "public boolean isNotEmpty() {\n        return size > 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "isNotEmpty",
        "javadoc": "/**\n     * Tests if the string builder is not empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return {@code true} if the size is greater than {@code 0}.\n     * @since 1.10.0\n     */"
    },
    {
        "signature": "public int lastIndexOf(final StrMatcher matcher, int startIndex)",
        "implementation": "public int lastIndexOf(final StrMatcher matcher, int startIndex) {\n        startIndex = startIndex >= size ? size - 1 : startIndex;\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        final char[] buf = buffer;\n        final int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }",
        "called_methods": [
            "lastIndexOf",
            "length",
            "charAt",
            "isMatch"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "lastIndexOf",
        "javadoc": "/**\n     * Searches the string builder using the matcher to find the last match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behavior. For example you could write a matcher to find the character 'a' followed by a number.\n     * </p>\n     *\n     * @param matcher    the matcher to use, null returns -1\n     * @param startIndex the index to start at, invalid index rounded to edge\n     * @return The last index matched, or -1 if not found\n     */"
    },
    {
        "signature": "public String leftString(final int length)",
        "implementation": "public String leftString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, 0, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "leftString",
        "javadoc": "/**\n     * Extracts the leftmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the left {@code length} characters from the builder. If this many characters are not available, the whole builder is returned. Thus\n     * the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public int length()",
        "implementation": "public int length() {\n        return size;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "length",
        "javadoc": "/**\n     * Gets the length of the string builder.\n     *\n     * @return The length\n     */"
    },
    {
        "signature": "public String midString(int index, final int length)",
        "implementation": "public String midString(int index, final int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return StringUtils.EMPTY;\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        }\n        return new String(buffer, index, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "midString",
        "javadoc": "/**\n     * Extracts some characters from the middle of the string builder without throwing an exception.\n     * <p>\n     * This method extracts {@code length} characters from the builder at the specified index. If the index is negative it is treated as zero. If the index is\n     * greater than the builder size, it is treated as the builder size. If the length is negative, the empty string is returned. If insufficient characters are\n     * available in the builder, as much as possible is returned. Thus the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param index  the index to start at, negative means zero\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public StrBuilder minimizeCapacity()",
        "implementation": "public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            final char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }",
        "called_methods": [
            "length",
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "minimizeCapacity",
        "javadoc": "/**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public int readFrom(final Readable readable) throws IOException",
        "implementation": "public int readFrom(final Readable readable) throws IOException {\n        final int oldSize = size;\n        if (readable instanceof Reader) {\n            final Reader r = (Reader) readable;\n            ensureCapacity(size + 1);\n            int read;\n            while ((read = r.read(buffer, size, buffer.length - size)) != -1) {\n                size += read;\n                ensureCapacity(size + 1);\n            }\n        } else if (readable instanceof CharBuffer) {\n            final CharBuffer cb = (CharBuffer) readable;\n            final int remaining = cb.remaining();\n            ensureCapacity(size + remaining);\n            cb.get(buffer, size, remaining);\n            size += remaining;\n        } else {\n            while (true) {\n                ensureCapacity(size + 1);\n                final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n                final int read = readable.read(buf);\n                if (read == -1) {\n                    break;\n                }\n                size += read;\n            }\n        }\n        return size - oldSize;\n    }",
        "called_methods": [
            "ensureCapacity",
            "read",
            "remaining",
            "get",
            "wrap"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "readFrom",
        "javadoc": "/**\n     * If possible, reads chars from the provided {@link Readable} directly into underlying character buffer without making extra copies.\n     *\n     * @param readable object to read from\n     * @return The number of characters read\n     * @throws IOException if an I/O error occurs.\n     * @see #appendTo(Appendable)\n     */"
    },
    {
        "signature": "public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount)",
        "implementation": "public StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }",
        "called_methods": [
            "validateRange",
            "length",
            "replaceImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "replace",
        "javadoc": "/**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all occurrences where the character 'a' is followed by\n     * a number.\n     * </p>\n     *\n     * @param matcher      the matcher to use to find the deletion, null causes no action\n     * @param replaceStr   the string to replace the match with, null is a delete\n     * @param startIndex   the start index, inclusive, must be valid\n     * @param endIndex     the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr)",
        "implementation": "public StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }",
        "called_methods": [
            "length",
            "indexOf",
            "replaceImpl",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "replaceAll",
        "javadoc": "/**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace all occurrences where the character 'a' is\n     * followed by a number.\n     * </p>\n     *\n     * @param matcher    the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr)",
        "implementation": "public StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }",
        "called_methods": [
            "length",
            "indexOf",
            "replaceImpl",
            "replace"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "replaceFirst",
        "javadoc": "/**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behavior. For example you could write a matcher to replace where the character 'a' is followed by a\n     * number.\n     * </p>\n     *\n     * @param matcher    the matcher to use to find the deletion, null causes no action\n     * @param replaceStr the replace string, null is equivalent to an empty string\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount)",
        "implementation": "private StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        final int replaceLen = replaceStr == null ? 0 : replaceStr.length();\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            final char[] buf = buffer;\n            final int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacity",
            "arraycopy",
            "getChars",
            "length",
            "isMatch",
            "replaceImpl"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "replaceImpl",
        "javadoc": "/**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behavior. For example you could write a matcher to delete all occurrences where the character 'a' is followed by\n     * a number.\n     * </p>\n     *\n     * @param matcher      the matcher to use to find the deletion, null causes no action\n     * @param replaceStr   the string to replace the match with, null is a delete\n     * @param from         the start index, must be valid\n     * @param to           the end index (exclusive), must be valid\n     * @param replaceCount the number of times to replace, -1 for replace all\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder reverse()",
        "implementation": "public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n\n        final int half = size / 2;\n        final char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {\n            final char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "reverse",
        "javadoc": "/**\n     * Reverses the string builder placing each character in the opposite index.\n     *\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public String rightString(final int length)",
        "implementation": "public String rightString(final int length) {\n        if (length <= 0) {\n            return StringUtils.EMPTY;\n        }\n        if (length >= size) {\n            return new String(buffer, 0, size);\n        }\n        return new String(buffer, size - length, length);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "rightString",
        "javadoc": "/**\n     * Extracts the rightmost characters from the string builder without throwing an exception.\n     * <p>\n     * This method extracts the right {@code length} characters from the builder. If this many characters are not available, the whole builder is returned. Thus\n     * the returned string may be shorter than the length requested.\n     * </p>\n     *\n     * @param length the number of characters to extract, negative returns empty string\n     * @return The new string\n     */"
    },
    {
        "signature": "public StrBuilder setCharAt(final int index, final char ch)",
        "implementation": "public StrBuilder setCharAt(final int index, final char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }",
        "called_methods": [
            "length"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "setCharAt",
        "javadoc": "/**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index the index to set\n     * @param ch    the new character\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public StrBuilder setLength(final int length)",
        "implementation": "public StrBuilder setLength(final int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            Arrays.fill(buffer, size, length, CharUtils.NUL);\n            size = length;\n        }\n        return this;\n    }",
        "called_methods": [
            "ensureCapacity",
            "fill"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "setLength",
        "javadoc": "/**\n     * Updates the length of the builder by either dropping the last characters or adding filler of Unicode zero.\n     *\n     * @param length the length to set to, must be zero or positive\n     * @return {@code this} instance.\n     * @throws IndexOutOfBoundsException if the length is negative\n     */"
    },
    {
        "signature": "public StrBuilder setNewLineText(final String newLine)",
        "implementation": "public StrBuilder setNewLineText(final String newLine) {\n        this.newLine = newLine;\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "setNewLineText",
        "javadoc": "/**\n     * Sets the text to be appended when {@link #appendNewLine() new line} is called.\n     *\n     * @param newLine the new line text, {@code null} means use the system default from {@link System#lineSeparator()}.\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public StrBuilder setNullText(String nullText)",
        "implementation": "public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.isEmpty()) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }",
        "called_methods": [
            "isEmpty"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "setNullText",
        "javadoc": "/**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText the null text, null means no append\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "public int size()",
        "implementation": "public int size() {\n        return size;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "size",
        "javadoc": "/**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the API of Collections.\n     * </p>\n     *\n     * @return The length\n     */"
    },
    {
        "signature": "public boolean startsWith(final String str)",
        "implementation": "public boolean startsWith(final String str) {\n        if (str == null) {\n            return false;\n        }\n        final int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "called_methods": [
            "length",
            "charAt"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "startsWith",
        "javadoc": "/**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * </p>\n     *\n     * @param str the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */"
    },
    {
        "signature": "public CharSequence subSequence(final int startIndex, final int endIndex)",
        "implementation": "public CharSequence subSequence(final int startIndex, final int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n        }\n        return substring(startIndex, endIndex);\n    }",
        "called_methods": [
            "substring"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "subSequence",
        "javadoc": "/**\n     * {@inheritDoc}\n     */"
    },
    {
        "signature": "public String substring(final int startIndex, int endIndex)",
        "implementation": "public String substring(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }",
        "called_methods": [
            "substring",
            "validateRange"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "substring",
        "javadoc": "/**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the builder as equal to the length of the builder, and continues without error, unlike\n     * StringBuffer or String.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex   the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "public char[] toCharArray(final int startIndex, int endIndex)",
        "implementation": "public char[] toCharArray(final int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        final int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        final char[] chars = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }",
        "called_methods": [
            "copyOf",
            "validateRange",
            "arraycopy"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "toCharArray",
        "javadoc": "/**\n     * Copies part of the builder's character array into a new character array.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex   the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid, or if endIndex is invalid (but endIndex greater than size is valid)\n     */"
    },
    {
        "signature": "public StringBuffer toStringBuffer()",
        "implementation": "public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "toStringBuffer",
        "javadoc": "/**\n     * Gets a StringBuffer version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuffer\n     */"
    },
    {
        "signature": "public StringBuilder toStringBuilder()",
        "implementation": "public StringBuilder toStringBuilder() {\n        return new StringBuilder(size).append(buffer, 0, size);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "toStringBuilder",
        "javadoc": "/**\n     * Gets a StringBuilder version of the string builder, creating a new instance each time the method is called.\n     *\n     * @return The builder as a StringBuilder\n     */"
    },
    {
        "signature": "public StrBuilder trim()",
        "implementation": "public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        final char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }",
        "called_methods": [
            "delete"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "trim",
        "javadoc": "/**\n     * Trims the builder by removing characters less than or equal to a space from the beginning and end.\n     *\n     * @return {@code this} instance.\n     */"
    },
    {
        "signature": "protected void validateIndex(final int index)",
        "implementation": "protected void validateIndex(final int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "validateIndex",
        "javadoc": "/**\n     * Validates parameters defining a single index in the builder.\n     *\n     * @param index the index, must be valid\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    },
    {
        "signature": "protected int validateRange(final int startIndex, int endIndex)",
        "implementation": "protected int validateRange(final int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrBuilder.java",
        "name": "validateRange",
        "javadoc": "/**\n     * Validates parameters defining a range of the builder.\n     *\n     * @param startIndex the start index, inclusive, must be valid\n     * @param endIndex   the end index, exclusive, must be valid except that if too large it is treated as end of string\n     * @return The new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */"
    }
]