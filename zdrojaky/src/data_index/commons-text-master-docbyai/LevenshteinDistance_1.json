[
    {
        "signature": "public static LevenshteinDistance getDefaultInstance()",
        "implementation": "public static LevenshteinDistance getDefaultInstance() {\n        return INSTANCE;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "getDefaultInstance",
        "javadoc": "/**\n     * Gets the default instance.\n     *\n     * @return The default instance\n     */"
    },
    {
        "signature": "private static <E> int limitedCompare(SimilarityInput<E> left, SimilarityInput<E> right, final int threshold)",
        "implementation": "private static <E> int limitedCompare(SimilarityInput<E> left, SimilarityInput<E> right, final int threshold) { // NOPMD\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        /*\n         * This implementation only computes the distance if it's less than or equal to the threshold value, returning -1 if it's greater. The advantage is\n         * performance: unbounded distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only computing a diagonal stripe of width 2k + 1\n         * of the cost table. It is also possible to use this to compute the unbounded Levenshtein distance by starting the threshold at 1 and doubling each\n         * time until the distance is found; this is O(dm), where d is the distance.\n         *\n         * One subtlety comes from needing to ignore entries on the border of our stripe eg. p[] = |#|#|#|* d[] = *|#|#|#| We must ignore the entry to the left\n         * of the leftmost member We must ignore the entry above the rightmost member\n         *\n         * Another subtlety comes from our stripe running off the matrix if the strings aren't of the same size. Since string s is always swapped to be the\n         * shorter of the two, the stripe will always run off to the upper right instead of the lower left of the matrix.\n         *\n         * As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1. In this case we're going to walk a stripe of length 3. The\n         * matrix would look like so:\n         *\n         * <pre> 1 2 3 4 5 1 |#|#| | | | 2 |#|#|#| | | 3 | |#|#|#| | 4 | | |#|#|#| 5 | | | |#|#| 6 | | | | |#| 7 | | | | | | </pre>\n         *\n         * Note how the stripe leads off the table as there is no possible way to turn a string of length 5 into one of length 7 in edit distance of 1.\n         *\n         * Additionally, this implementation decreases memory usage by using two single-dimensional arrays and swapping them back and forth instead of\n         * allocating an entire n by m matrix. This requires a few minor changes, such as immediately returning when it's detected that the stripe has run off\n         * the matrix and initially filling the arrays with large values so that entries we don't compute are ignored.\n         *\n         * See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n         */\n\n        int n = left.length(); // length of left\n        int m = right.length(); // length of right\n\n        // if one string is empty, the edit distance is necessarily the length\n        // of the other\n        if (n == 0) {\n            return m <= threshold ? m : -1;\n        }\n        if (m == 0) {\n            return n <= threshold ? n : -1;\n        }\n\n        if (n > m) {\n            // swap the two strings to consume less memory\n            final SimilarityInput<E> tmp = left;\n            left = right;\n            right = tmp;\n            n = m;\n            m = right.length();\n        }\n\n        // the edit distance cannot be less than the length difference\n        if (m - n > threshold) {\n            return -1;\n        }\n\n        int[] p = new int[n + 1]; // 'previous' cost array, horizontally\n        int[] d = new int[n + 1]; // cost array, horizontally\n        int[] tempD; // placeholder to assist in swapping p and d\n\n        // fill in starting table values\n        final int boundary = Math.min(n, threshold) + 1;\n        for (int i = 0; i < boundary; i++) {\n            p[i] = i;\n        }\n        // these fills ensure that the value above the rightmost entry of our\n        // stripe will be ignored in following loop iterations\n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        // iterates through t\n        for (int j = 1; j <= m; j++) {\n            final E rightJ = right.at(j - 1); // jth character of right\n            d[0] = j;\n\n            // compute stripe indices, constrain to array size\n            final int min = Math.max(1, j - threshold);\n            final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);\n\n            // ignore entry left of leftmost\n            if (min > 1) {\n                d[min - 1] = Integer.MAX_VALUE;\n            }\n\n            int lowerBound = Integer.MAX_VALUE;\n            // iterates through [min, max] in s\n            for (int i = min; i <= max; i++) {\n                if (left.at(i - 1).equals(rightJ)) {\n                    // diagonally left and up\n                    d[i] = p[i - 1];\n                } else {\n                    // 1 + minimum of cell to the left, to the top, diagonally\n                    // left and up\n                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n                lowerBound = Math.min(lowerBound, d[i]);\n            }\n            // if the lower bound is greater than the threshold, then exit early\n            if (lowerBound > threshold) {\n                return -1;\n            }\n\n            // copy current distance counts to 'previous row' distance counts\n            tempD = p;\n            p = d;\n            d = tempD;\n        }\n\n        // if p[n] is greater than the threshold, there's no guarantee on it\n        // being the correct\n        // distance\n        if (p[n] <= threshold) {\n            return p[n];\n        }\n        return -1;\n    }",
        "called_methods": [
            "length",
            "min",
            "fill",
            "at",
            "max",
            "equals"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "limitedCompare",
        "javadoc": "/**\n     * Find the Levenshtein distance between two CharSequences if it's less than or equal to a given threshold.\n     *\n     * <p>\n     * This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield and Chas Emerick's implementation of the Levenshtein distance\n     * algorithm from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a>\n     * </p>\n     *\n     * <pre>\n     * limitedCompare(null, *, *)             = IllegalArgumentException\n     * limitedCompare(*, null, *)             = IllegalArgumentException\n     * limitedCompare(*, *, -1)               = IllegalArgumentException\n     * limitedCompare(\"\",\"\", 0)               = 0\n     * limitedCompare(\"aaapppp\", \"\", 8)       = 7\n     * limitedCompare(\"aaapppp\", \"\", 7)       = 7\n     * limitedCompare(\"aaapppp\", \"\", 6))      = -1\n     * limitedCompare(\"elephant\", \"hippo\", 7) = 7\n     * limitedCompare(\"elephant\", \"hippo\", 6) = -1\n     * limitedCompare(\"hippo\", \"elephant\", 7) = 7\n     * limitedCompare(\"hippo\", \"elephant\", 6) = -1\n     * </pre>\n     *\n     * @param left      the first SimilarityInput, must not be null\n     * @param right     the second SimilarityInput, must not be null\n     * @param threshold the target threshold, must not be negative\n     * @return result distance, or -1\n     */"
    },
    {
        "signature": "private static <E> int unlimitedCompare(SimilarityInput<E> left, SimilarityInput<E> right)",
        "implementation": "private static <E> int unlimitedCompare(SimilarityInput<E> left, SimilarityInput<E> right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n        /*\n         * This implementation use two variable to record the previous cost counts, So this implementation use less memory than previous impl.\n         */\n        int n = left.length(); // length of left\n        int m = right.length(); // length of right\n\n        if (n == 0) {\n            return m;\n        }\n        if (m == 0) {\n            return n;\n        }\n        if (n > m) {\n            // swap the input strings to consume less memory\n            final SimilarityInput<E> tmp = left;\n            left = right;\n            right = tmp;\n            n = m;\n            m = right.length();\n        }\n        final int[] p = new int[n + 1];\n        // indexes into strings left and right\n        int i; // iterates through left\n        int j; // iterates through right\n        int upperLeft;\n        int upper;\n        E rightJ; // jth character of right\n        int cost; // cost\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n        for (j = 1; j <= m; j++) {\n            upperLeft = p[0];\n            rightJ = right.at(j - 1);\n            p[0] = j;\n\n            for (i = 1; i <= n; i++) {\n                upper = p[i];\n                cost = left.at(i - 1).equals(rightJ) ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upperLeft + cost);\n                upperLeft = upper;\n            }\n        }\n        return p[n];\n    }",
        "called_methods": [
            "length",
            "at",
            "equals",
            "min"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "unlimitedCompare",
        "javadoc": "/**\n     * Finds the Levenshtein distance between two Strings.\n     *\n     * <p>\n     * A higher score indicates a greater distance.\n     * </p>\n     *\n     * <p>\n     * The previous implementation of the Levenshtein distance algorithm was from\n     * <a href=\"https://web.archive.org/web/20120526085419/http://www.merriampark.com/ldjava.htm\">\n     * https://web.archive.org/web/20120526085419/http://www.merriampark.com/ldjava.htm</a>\n     * </p>\n     *\n     * <p>\n     * This implementation only need one single-dimensional arrays of length s.length() + 1\n     * </p>\n     *\n     * <pre>\n     * unlimitedCompare(null, *)             = IllegalArgumentException\n     * unlimitedCompare(*, null)             = IllegalArgumentException\n     * unlimitedCompare(\"\",\"\")               = 0\n     * unlimitedCompare(\"\",\"a\")              = 1\n     * unlimitedCompare(\"aaapppp\", \"\")       = 7\n     * unlimitedCompare(\"frog\", \"fog\")       = 1\n     * unlimitedCompare(\"fly\", \"ant\")        = 3\n     * unlimitedCompare(\"elephant\", \"hippo\") = 7\n     * unlimitedCompare(\"hippo\", \"elephant\") = 7\n     * unlimitedCompare(\"hippo\", \"zzzzzzzz\") = 8\n     * unlimitedCompare(\"hello\", \"hallo\")    = 1\n     * </pre>\n     *\n     * @param left  the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @return result distance, or -1\n     * @throws IllegalArgumentException if either CharSequence input is {@code null}\n     */"
    },
    {
        "signature": "public <E> Integer apply(final SimilarityInput<E> left, final SimilarityInput<E> right)",
        "implementation": "public <E> Integer apply(final SimilarityInput<E> left, final SimilarityInput<E> right) {\n        if (threshold != null) {\n            return limitedCompare(left, right, threshold);\n        }\n        return unlimitedCompare(left, right);\n    }",
        "called_methods": [
            "apply",
            "input",
            "limitedCompare",
            "unlimitedCompare"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "apply",
        "javadoc": "/**\n     * Computes the Levenshtein distance between two inputs.\n     *\n     * <p>\n     * A higher score indicates a greater distance.\n     * </p>\n     *\n     * <pre>\n     * distance.apply(null, *)             = IllegalArgumentException\n     * distance.apply(*, null)             = IllegalArgumentException\n     * distance.apply(\"\",\"\")               = 0\n     * distance.apply(\"\",\"a\")              = 1\n     * distance.apply(\"aaapppp\", \"\")       = 7\n     * distance.apply(\"frog\", \"fog\")       = 1\n     * distance.apply(\"fly\", \"ant\")        = 3\n     * distance.apply(\"elephant\", \"hippo\") = 7\n     * distance.apply(\"hippo\", \"elephant\") = 7\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 8\n     * distance.apply(\"hello\", \"hallo\")    = 1\n     * </pre>\n     *\n     * @param <E>   The type of similarity score unit.\n     * @param left  the first input, must not be null.\n     * @param right the second input, must not be null.\n     * @return result distance, or -1.\n     * @throws IllegalArgumentException if either String input {@code null}.\n     * @since 1.13.0\n     */"
    },
    {
        "signature": "public Integer getThreshold()",
        "implementation": "public Integer getThreshold() {\n        return threshold;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "getThreshold",
        "javadoc": "/**\n     * Gets the distance threshold.\n     *\n     * @return The distance threshold\n     */"
    }
]