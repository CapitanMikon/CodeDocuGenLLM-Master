[
    {
        "signature": "public String replace(final StringBuffer source, final int offset, final int length)",
        "implementation": "public String replace(final StringBuffer source, final int offset, final int length) {\n        if (source == null) {\n            return null;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        substitute(buf, 0, length);\n        return buf.toString();\n    }",
        "called_methods": [
            "replace",
            "toString",
            "stringPropertyNames",
            "stream",
            "collect",
            "toMap",
            "identity",
            "append",
            "substitute",
            "length",
            "substring"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "replace",
        "javadoc": "/**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source buffer as a template.\n     * The buffer is not altered by this method.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, and is not returned.\n     * </p>\n     *\n     * @param source  the buffer to use as a template, not changed, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return The result of the replace operation\n     */"
    },
    {
        "signature": "public static String replaceSystemProperties(final Object source)",
        "implementation": "public static String replaceSystemProperties(final Object source) {\n        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n    }",
        "called_methods": [
            "replace",
            "systemPropertiesLookup"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "replaceSystemProperties",
        "javadoc": "/**\n     * Replaces all the occurrences of variables in the given source object with\n     * their matching values from the system properties.\n     *\n     * @param source  the source text containing the variables to substitute, null returns null\n     * @return The result of the replace operation\n     */"
    },
    {
        "signature": "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)",
        "implementation": "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables) {\n        if (!priorVariables.contains(varName)) {\n            return;\n        }\n        final StrBuilder buf = new StrBuilder(256);\n        buf.append(\"Infinite loop in property interpolation of \");\n        buf.append(priorVariables.remove(0));\n        buf.append(\": \");\n        buf.appendWithSeparators(priorVariables, \"->\");\n        throw new IllegalStateException(buf.toString());\n    }",
        "called_methods": [
            "contains",
            "append",
            "remove",
            "appendWithSeparators",
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "checkCyclicSubstitution",
        "javadoc": "/**\n     * Checks if the specified variable is already in the stack (list) of variables.\n     *\n     * @param varName  the variable name to check\n     * @param priorVariables  the list of prior variables\n     */"
    },
    {
        "signature": "public char getEscapeChar()",
        "implementation": "public char getEscapeChar() {\n        return this.escapeChar;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "getEscapeChar",
        "javadoc": "/**\n     * Returns the escape character.\n     *\n     * @return The character used for escaping variable references\n     */"
    },
    {
        "signature": "public StrMatcher getValueDelimiterMatcher()",
        "implementation": "public StrMatcher getValueDelimiterMatcher() {\n        return valueDelimiterMatcher;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "getValueDelimiterMatcher",
        "javadoc": "/**\n     * Gets the variable default value delimiter matcher currently in use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * </p>\n     * <p>\n     * If it returns null, then the variable default value resolution is disabled.\n     * </p>\n     *\n     * @return The variable default value delimiter matcher in use, may be null\n     */"
    },
    {
        "signature": "public StrMatcher getVariablePrefixMatcher()",
        "implementation": "public StrMatcher getVariablePrefixMatcher() {\n        return prefixMatcher;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "getVariablePrefixMatcher",
        "javadoc": "/**\n     * Gets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     * </p>\n     *\n     * @return The prefix matcher in use\n     */"
    },
    {
        "signature": "public StrLookup<?> getVariableResolver()",
        "implementation": "public StrLookup<?> getVariableResolver() {\n        return this.variableResolver;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "getVariableResolver",
        "javadoc": "/**\n     * Gets the VariableResolver that is used to lookup variables.\n     *\n     * @return The VariableResolver\n     */"
    },
    {
        "signature": "public StrMatcher getVariableSuffixMatcher()",
        "implementation": "public StrMatcher getVariableSuffixMatcher() {\n        return suffixMatcher;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "getVariableSuffixMatcher",
        "javadoc": "/**\n     * Gets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     * </p>\n     *\n     * @return The suffix matcher in use\n     */"
    },
    {
        "signature": "public boolean isDisableSubstitutionInValues()",
        "implementation": "public boolean isDisableSubstitutionInValues() {\n        return disableSubstitutionInValues;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "isDisableSubstitutionInValues",
        "javadoc": "/**\n     * Returns a flag whether substitution is disabled in variable values.If set to\n     * <strong>true</strong>, the values of variables can contain other variables will not be\n     * processed and substituted original variable is evaluated, e.g.\n     * <pre>\n     * Map&lt;String, String&gt; valuesMap = new HashMap&lt;&gt;();\n     * valuesMap.put(&quot;name&quot;, &quot;Douglas ${surname}&quot;);\n     * valuesMap.put(&quot;surname&quot;, &quot;Crockford&quot;);\n     * String templateString = &quot;Hi ${name}&quot;;\n     * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n     * String resolvedString = sub.replace(templateString);\n     * </pre>\n     * yielding:\n     * <pre>\n     *      Hi Douglas ${surname}\n     * </pre>\n     *\n     * @return The substitution in variable values flag\n     * @since 1.2\n     */"
    },
    {
        "signature": "public boolean isEnableSubstitutionInVariables()",
        "implementation": "public boolean isEnableSubstitutionInVariables() {\n        return enableSubstitutionInVariables;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "isEnableSubstitutionInVariables",
        "javadoc": "/**\n     * Returns a flag whether substitution is done in variable names.\n     *\n     * @return The substitution in variable names flag\n     */"
    },
    {
        "signature": "public boolean isPreserveEscapes()",
        "implementation": "public boolean isPreserveEscapes() {\n        return preserveEscapes;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "isPreserveEscapes",
        "javadoc": "/**\n     * Returns the flag controlling whether escapes are preserved during\n     * substitution.\n     *\n     * @return The preserve escape flag\n     */"
    },
    {
        "signature": "public boolean replaceIn(final StringBuilder source, final int offset, final int length)",
        "implementation": "public boolean replaceIn(final StringBuilder source, final int offset, final int length) {\n        if (source == null) {\n            return false;\n        }\n        final StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n        if (!substitute(buf, 0, length)) {\n            return false;\n        }\n        source.replace(offset, offset + length, buf.toString());\n        return true;\n    }",
        "called_methods": [
            "substitute",
            "length",
            "replaceIn",
            "append",
            "replace",
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "replaceIn",
        "javadoc": "/**\n     * Replaces all the occurrences of variables within the given source builder\n     * with their matching values from the resolver.\n     * The builder is updated with the result.\n     * <p>\n     * Only the specified portion of the buffer will be processed.\n     * The rest of the buffer is not processed, but it is not deleted.\n     * </p>\n     *\n     * @param source  the buffer to replace in, updated, null returns zero\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return true if altered\n     */"
    },
    {
        "signature": "protected String resolveVariable(final String variableName,\n                                     final StrBuilder buf,\n                                     final int startPos,\n                                     final int endPos)",
        "implementation": "protected String resolveVariable(final String variableName,\n                                     final StrBuilder buf,\n                                     final int startPos,\n                                     final int endPos) {\n        final StrLookup<?> resolver = getVariableResolver();\n        if (resolver == null) {\n            return null;\n        }\n        return resolver.lookup(variableName);\n    }",
        "called_methods": [
            "getVariableResolver",
            "lookup"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "resolveVariable",
        "javadoc": "/**\n     * Internal method that resolves the value of a variable.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * </p>\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the variable's name\n     * and must return the corresponding value. This implementation uses the\n     * {@link #getVariableResolver()} with the variable's name as the key.\n     * </p>\n     *\n     * @param variableName  the name of the variable, not null\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param startPos  the start position of the variable including the prefix, valid\n     * @param endPos  the end position of the variable including the suffix, valid\n     * @return The variable's value or <strong>null</strong> if the variable is unknown\n     */"
    },
    {
        "signature": "public void setDisableSubstitutionInValues(final boolean disableSubstitutionInValues)",
        "implementation": "public void setDisableSubstitutionInValues(final boolean disableSubstitutionInValues) {\n        this.disableSubstitutionInValues = disableSubstitutionInValues;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setDisableSubstitutionInValues",
        "javadoc": "/**\n     * Sets a flag whether substitution is done in variable values (recursive).\n     *\n     * @param disableSubstitutionInValues true if substitution in variable value are disabled\n     * @since 1.2\n     */"
    },
    {
        "signature": "public void setEnableSubstitutionInVariables(\n            final boolean enableSubstitutionInVariables)",
        "implementation": "public void setEnableSubstitutionInVariables(\n            final boolean enableSubstitutionInVariables) {\n        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setEnableSubstitutionInVariables",
        "javadoc": "/**\n     * Sets a flag whether substitution is done in variable names. If set to\n     * <strong>true</strong>, the names of variables can contain other variables which are\n     * processed first before the original variable is evaluated, e.g.\n     * {@code ${jre-${java.version}}}. The default value is <strong>false</strong>.\n     *\n     * @param enableSubstitutionInVariables the new value of the flag\n     */"
    },
    {
        "signature": "public void setEscapeChar(final char escapeCharacter)",
        "implementation": "public void setEscapeChar(final char escapeCharacter) {\n        this.escapeChar = escapeCharacter;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setEscapeChar",
        "javadoc": "/**\n     * Sets the escape character.\n     * If this character is placed before a variable reference in the source\n     * text, this variable will be ignored.\n     *\n     * @param escapeCharacter  the escape character (0 for disabling escaping)\n     */"
    },
    {
        "signature": "public void setPreserveEscapes(final boolean preserveEscapes)",
        "implementation": "public void setPreserveEscapes(final boolean preserveEscapes) {\n        this.preserveEscapes = preserveEscapes;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setPreserveEscapes",
        "javadoc": "/**\n     * Sets a flag controlling whether escapes are preserved during\n     * substitution.  If set to <strong>true</strong>, the escape character is retained\n     * during substitution (e.g. {@code $${this-is-escaped}} remains\n     * {@code $${this-is-escaped}}).  If set to <strong>false</strong>, the escape\n     * character is removed during substitution (e.g.\n     * {@code $${this-is-escaped}} becomes\n     * {@code ${this-is-escaped}}).  The default value is <strong>false</strong>\n     *\n     * @param preserveEscapes true if escapes are to be preserved\n     */"
    },
    {
        "signature": "public StrSubstitutor setValueDelimiter(final String valueDelimiter)",
        "implementation": "public StrSubstitutor setValueDelimiter(final String valueDelimiter) {\n        if (valueDelimiter == null || valueDelimiter.isEmpty()) {\n            setValueDelimiterMatcher(null);\n            return this;\n        }\n        return setValueDelimiterMatcher(StrMatcher.stringMatcher(valueDelimiter));\n    }",
        "called_methods": [
            "setValueDelimiterMatcher",
            "charMatcher",
            "isEmpty",
            "stringMatcher"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setValueDelimiter",
        "javadoc": "/**\n     * Sets the variable default value delimiter to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This method allows a string\n     * variable default value delimiter to be easily set.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiter} is null or empty string, then the variable default\n     * value resolution becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiter  the variable default value delimiter string to use, may be null or empty\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMatcher)",
        "implementation": "public StrSubstitutor setValueDelimiterMatcher(final StrMatcher valueDelimiterMatcher) {\n        this.valueDelimiterMatcher = valueDelimiterMatcher;\n        return this;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setValueDelimiterMatcher",
        "javadoc": "/**\n     * Sets the variable default value delimiter matcher to use.\n     * <p>\n     * The variable default value delimiter is the character or characters that delimit the\n     * variable name and the variable default value. This delimiter is expressed in terms of a matcher\n     * allowing advanced variable default value delimiter matches.\n     * </p>\n     * <p>\n     * If the {@code valueDelimiterMatcher} is null, then the variable default value resolution\n     * becomes disabled.\n     * </p>\n     *\n     * @param valueDelimiterMatcher  variable default value delimiter matcher to use, may be null\n     * @return this, to enable chaining\n     */"
    },
    {
        "signature": "public StrSubstitutor setVariablePrefix(final String prefix)",
        "implementation": "public StrSubstitutor setVariablePrefix(final String prefix) {\n        Validate.isTrue(prefix != null, \"Variable prefix must not be null!\");\n        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n    }",
        "called_methods": [
            "setVariablePrefixMatcher",
            "charMatcher",
            "isTrue",
            "stringMatcher"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setVariablePrefix",
        "javadoc": "/**\n     * Sets the variable prefix to use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This method allows a string prefix to be easily set.\n     * </p>\n     *\n     * @param prefix  the prefix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix is null\n     */"
    },
    {
        "signature": "public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher)",
        "implementation": "public StrSubstitutor setVariablePrefixMatcher(final StrMatcher prefixMatcher) {\n        Validate.isTrue(prefixMatcher != null, \"Variable prefix matcher must not be null!\");\n        this.prefixMatcher = prefixMatcher;\n        return this;\n    }",
        "called_methods": [
            "isTrue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setVariablePrefixMatcher",
        "javadoc": "/**\n     * Sets the variable prefix matcher currently in use.\n     * <p>\n     * The variable prefix is the character or characters that identify the\n     * start of a variable. This prefix is expressed in terms of a matcher\n     * allowing advanced prefix matches.\n     * </p>\n     *\n     * @param prefixMatcher  the prefix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the prefix matcher is null\n     */"
    },
    {
        "signature": "public void setVariableResolver(final StrLookup<?> variableResolver)",
        "implementation": "public void setVariableResolver(final StrLookup<?> variableResolver) {\n        this.variableResolver = variableResolver;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setVariableResolver",
        "javadoc": "/**\n     * Sets the VariableResolver that is used to lookup variables.\n     *\n     * @param variableResolver  the VariableResolver\n     */"
    },
    {
        "signature": "public StrSubstitutor setVariableSuffix(final String suffix)",
        "implementation": "public StrSubstitutor setVariableSuffix(final String suffix) {\n        Validate.isTrue(suffix != null, \"Variable suffix must not be null!\");\n        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n    }",
        "called_methods": [
            "setVariableSuffixMatcher",
            "charMatcher",
            "isTrue",
            "stringMatcher"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setVariableSuffix",
        "javadoc": "/**\n     * Sets the variable suffix to use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This method allows a string suffix to be easily set.\n     * </p>\n     *\n     * @param suffix  the suffix for variables, not null\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix is null\n     */"
    },
    {
        "signature": "public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher)",
        "implementation": "public StrSubstitutor setVariableSuffixMatcher(final StrMatcher suffixMatcher) {\n        Validate.isTrue(suffixMatcher != null, \"Variable suffix matcher must not be null!\");\n        this.suffixMatcher = suffixMatcher;\n        return this;\n    }",
        "called_methods": [
            "isTrue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "setVariableSuffixMatcher",
        "javadoc": "/**\n     * Sets the variable suffix matcher currently in use.\n     * <p>\n     * The variable suffix is the character or characters that identify the\n     * end of a variable. This suffix is expressed in terms of a matcher\n     * allowing advanced suffix matches.\n     * </p>\n     *\n     * @param suffixMatcher  the suffix matcher to use, null ignored\n     * @return this, to enable chaining\n     * @throws IllegalArgumentException if the suffix matcher is null\n     */"
    },
    {
        "signature": "private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables)",
        "implementation": "private int substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n        final StrMatcher pfxMatcher = getVariablePrefixMatcher();\n        final StrMatcher suffMatcher = getVariableSuffixMatcher();\n        final char escape = getEscapeChar();\n        final StrMatcher valueDelimMatcher = getValueDelimiterMatcher();\n        final boolean substitutionInVariablesEnabled = isEnableSubstitutionInVariables();\n        final boolean substitutionInValuesDisabled = isDisableSubstitutionInValues();\n\n        final boolean top = priorVariables == null;\n        boolean altered = false;\n        int lengthChange = 0;\n        char[] chars = buf.buffer;\n        int bufEnd = offset + length;\n        int pos = offset;\n        while (pos < bufEnd) {\n            final int startMatchLen = pfxMatcher.isMatch(chars, pos, offset,\n                    bufEnd);\n            if (startMatchLen == 0) {\n                pos++;\n            } else // found variable start marker\n            if (pos > offset && chars[pos - 1] == escape) {\n                // escaped\n                if (preserveEscapes) {\n                    pos++;\n                    continue;\n                }\n                buf.deleteCharAt(pos - 1);\n                chars = buf.buffer; // in case buffer was altered\n                lengthChange--;\n                altered = true;\n                bufEnd--;\n            } else {\n                // find suffix\n                final int startPos = pos;\n                pos += startMatchLen;\n                int endMatchLen = 0;\n                int nestedVarCount = 0;\n                while (pos < bufEnd) {\n                    if (substitutionInVariablesEnabled\n                            && pfxMatcher.isMatch(chars,\n                                    pos, offset, bufEnd) != 0) {\n                        // found a nested variable start\n                        endMatchLen = pfxMatcher.isMatch(chars,\n                                pos, offset, bufEnd);\n                        nestedVarCount++;\n                        pos += endMatchLen;\n                        continue;\n                    }\n\n                    endMatchLen = suffMatcher.isMatch(chars, pos, offset,\n                            bufEnd);\n                    if (endMatchLen == 0) {\n                        pos++;\n                    } else {\n                        // found variable end marker\n                        if (nestedVarCount == 0) {\n                            String varNameExpr = new String(chars, startPos\n                                    + startMatchLen, pos - startPos\n                                    - startMatchLen);\n                            if (substitutionInVariablesEnabled) {\n                                final StrBuilder bufName = new StrBuilder(varNameExpr);\n                                substitute(bufName, 0, bufName.length());\n                                varNameExpr = bufName.toString();\n                            }\n                            pos += endMatchLen;\n                            final int endPos = pos;\n\n                            String varName = varNameExpr;\n                            String varDefaultValue = null;\n\n                            if (valueDelimMatcher != null) {\n                                final char[] varNameExprChars = varNameExpr.toCharArray();\n                                int valueDelimiterMatchLen = 0;\n                                for (int i = 0; i < varNameExprChars.length; i++) {\n                                    // if there's any nested variable when nested variable substitution disabled,\n                                    // then stop resolving name and default value.\n                                    if (!substitutionInVariablesEnabled\n                                            && pfxMatcher.isMatch(varNameExprChars,\n                                                                    i,\n                                                                    i,\n                                                                    varNameExprChars.length) != 0) {\n                                        break;\n                                    }\n                                    if (valueDelimMatcher.isMatch(varNameExprChars, i) != 0) {\n                                        valueDelimiterMatchLen = valueDelimMatcher.isMatch(varNameExprChars, i);\n                                        varName = varNameExpr.substring(0, i);\n                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);\n                                        break;\n                                    }\n                                }\n                            }\n\n                            // on the first call initialize priorVariables\n                            if (priorVariables == null) {\n                                priorVariables = new ArrayList<>();\n                                priorVariables.add(new String(chars,\n                                        offset, length));\n                            }\n\n                            // handle cyclic substitution\n                            checkCyclicSubstitution(varName, priorVariables);\n                            priorVariables.add(varName);\n\n                            // resolve the variable\n                            String varValue = resolveVariable(varName, buf,\n                                    startPos, endPos);\n                            if (varValue == null) {\n                                varValue = varDefaultValue;\n                            }\n                            if (varValue != null) {\n                                final int varLen = varValue.length();\n                                buf.replace(startPos, endPos, varValue);\n                                altered = true;\n                                int change = 0;\n                                if (!substitutionInValuesDisabled) { // recursive replace\n                                    change = substitute(buf, startPos,\n                                        varLen, priorVariables);\n                                }\n                                change = change\n                                    + varLen - (endPos - startPos);\n                                pos += change;\n                                bufEnd += change;\n                                lengthChange += change;\n                                chars = buf.buffer; // in case buffer was\n                                                    // altered\n                            }\n\n                            // remove variable from the cyclic stack\n                            priorVariables\n                                    .remove(priorVariables.size() - 1);\n                            break;\n                        }\n                        nestedVarCount--;\n                        pos += endMatchLen;\n                    }\n                }\n            }\n        }\n        if (top) {\n            return altered ? 1 : 0;\n        }\n        return lengthChange;\n    }",
        "called_methods": [
            "substitute",
            "getVariablePrefixMatcher",
            "getVariableSuffixMatcher",
            "getEscapeChar",
            "getValueDelimiterMatcher",
            "isEnableSubstitutionInVariables",
            "isDisableSubstitutionInValues",
            "isMatch",
            "deleteCharAt",
            "length",
            "toString",
            "toCharArray",
            "substring",
            "add",
            "checkCyclicSubstitution",
            "resolveVariable",
            "replace",
            "remove",
            "size"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\StrSubstitutor.java",
        "name": "substitute",
        "javadoc": "/**\n     * Recursive handler for multiple levels of interpolation. This is the main\n     * interpolation method, which resolves the values of all variable references\n     * contained in the passed in text.\n     *\n     * @param buf  the string builder to substitute into, not null\n     * @param offset  the start offset within the builder, must be valid\n     * @param length  the length within the builder to be processed, must be valid\n     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n     * @return The length change that occurs, unless priorVariables is null when the int\n     *  represents a boolean flag as to whether any change occurred.\n     */"
    }
]