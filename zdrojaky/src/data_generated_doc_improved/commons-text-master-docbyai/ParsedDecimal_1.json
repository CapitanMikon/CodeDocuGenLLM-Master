[
    {
        "signature": "char getMinusSign();\n\n        /**\n         * Return",
        "implementation": "char getMinusSign();\n\n        /**\n         * Return {@code true} if exponent values should always be included in",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getMinusSign",
        "javadoc": "/**\n * Returns the minus sign character.\n *\n * @return the minus sign character\n */\n",
        "improved_javadoc": "/**\n * Returns the Unicode character representing the minus sign, which is '-' (U+002D).\n *\n * @return the minus sign character (-)\n */\n"
    },
    {
        "signature": "boolean isAlwaysIncludeExponent();\n\n        /**\n         * Return",
        "implementation": "boolean isAlwaysIncludeExponent();\n\n        /**\n         * Return {@code true} if thousands should be grouped.",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isAlwaysIncludeExponent",
        "javadoc": "/**\n * Returns {@code true} if an exponent should always be included.\n *\n * @return {@code true} if an exponent should always be included, otherwise {@code false}\n */\n",
        "improved_javadoc": "/**\n * Determines whether an exponent should always be included in the output.\n *\n * @param includeExponentAlways a boolean indicating whether to always include the exponent\n * @return true if the exponent should always be included, false otherwise\n */\n"
    },
    {
        "signature": "boolean isGroupThousands();\n\n        /**\n         * Return",
        "implementation": "boolean isGroupThousands();\n\n        /**\n         * Return {@code true} if fraction placeholders (e.g., {@code \".0\"} in {@code \"1.0\"})",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isGroupThousands",
        "javadoc": "/**\n * Returns whether group thousands are enabled.\n *\n * @return true if group thousands are enabled, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether the display of thousands separators (grouping) is enabled for numeric values.\n *\n * @return  {@code true} if thousands grouping is enabled, and {@code false} otherwise. \n */\n"
    },
    {
        "signature": "boolean isIncludeFractionPlaceholder();\n\n        /**\n         * Return",
        "implementation": "boolean isIncludeFractionPlaceholder();\n\n        /**\n         * Return {@code true} if the string zero should be prefixed with the minus sign",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isIncludeFractionPlaceholder",
        "javadoc": "/**\n * Returns whether the include fraction placeholder is present.\n *\n * @return true if the include fraction placeholder is present, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether the include fraction placeholder is present in the input string.\n *\n * @param input the input string to check for the include fraction placeholder\n * @return true if the include fraction placeholder is found in the input string, false otherwise\n */\n"
    },
    {
        "signature": "private static int digitValue(final char ch)",
        "implementation": "private static int digitValue(final char ch) {\n        return ch - ZERO_CHAR;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "digitValue",
        "javadoc": "/**\n * Returns the numeric value of a digit character.\n *\n * @param ch the digit character to be converted\n * @return the numeric value of the digit character (0-9)\n */\n",
        "improved_javadoc": "/**\n * Converts a single character representing a digit into its corresponding integer value.\n *\n * @param ch the character to convert, which must be a decimal digit ('0' through '9')\n * @return the numeric value of the digit character (0-9)\n */\n"
    },
    {
        "signature": "public static ParsedDecimal from(final double d)",
        "implementation": "public static ParsedDecimal from(final double d) {\n        if (!Double.isFinite(d)) {\n            throw new IllegalArgumentException(\"Double is not finite\");\n        }\n\n        // Get the canonical string representation of the double value and parse\n        // it to extract the components of the decimal value. From the documentation\n        // of Double.toString() and the fact that d is finite, we are guaranteed the\n        // following:\n        // - the string will not be empty\n        // - it will contain exactly one decimal point character\n        // - all digit characters are in the ASCII range\n        final char[] strChars = Double.toString(d).toCharArray();\n\n        final boolean negative = strChars[0] == MINUS_CHAR;\n        final int digitStartIdx = negative ? 1 : 0;\n\n        final int[] digits = new int[strChars.length - digitStartIdx - 1];\n\n        boolean foundDecimalPoint = false;\n        int digitCount = 0;\n        int significantDigitCount = 0;\n        int decimalPos = 0;\n\n        int i;\n        for (i = digitStartIdx; i < strChars.length; ++i) {\n            final char ch = strChars[i];\n\n            if (ch == DECIMAL_SEP_CHAR) {\n                foundDecimalPoint = true;\n                decimalPos = digitCount;\n            } else if (ch == EXPONENT_CHAR) {\n                // no more mantissa digits\n                break;\n            } else if (ch != ZERO_CHAR || digitCount > 0) {\n                // this is either the first non-zero digit or one after it\n                final int val = digitValue(ch);\n                digits[digitCount++] = val;\n\n                if (val > 0) {\n                    significantDigitCount = digitCount;\n                }\n            } else if (foundDecimalPoint) {\n                // leading zero in a fraction; adjust the decimal position\n                --decimalPos;\n            }\n        }\n\n        if (digitCount > 0) {\n            // determine the exponent\n            final int explicitExponent = i < strChars.length\n                    ? parseExponent(strChars, i + 1)\n                    : 0;\n            final int exponent = explicitExponent + decimalPos - significantDigitCount;\n\n            return new ParsedDecimal(negative, digits, significantDigitCount, exponent);\n        }\n\n        // no non-zero digits, so value is zero\n        return new ParsedDecimal(negative, new int[] {0}, 1, 0);\n    }",
        "called_methods": [
            "isFinite",
            "toString",
            "toCharArray",
            "digitValue",
            "parseExponent"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "from",
        "javadoc": "/**\n * Creates a parsed decimal from a double value.\n *\n * @param d the double value to parse\n * @return a parsed decimal representation of the input value\n * @throws IllegalArgumentException if the input double is not finite\n */\n",
        "improved_javadoc": "/**\n * Converts a double value into its equivalent decimal representation, \n * parsing it as a BigDecimal with maximum precision.\n *\n * @param d the double value to parse\n * @return a parsed decimal representation of the input value\n * @throws IllegalArgumentException if the input double is not finite (NaN or infinity)\n */\n"
    },
    {
        "signature": "private static int parseExponent(final char[] chars, final int start)",
        "implementation": "private static int parseExponent(final char[] chars, final int start) {\n        int i = start;\n        final boolean neg = chars[i] == MINUS_CHAR;\n        if (neg) {\n            ++i;\n        }\n\n        int exp = 0;\n        for (; i < chars.length; ++i) {\n            exp = exp * DECIMAL_RADIX + digitValue(chars[i]);\n        }\n\n        return neg ? -exp : exp;\n    }",
        "called_methods": [
            "digitValue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "parseExponent",
        "javadoc": "/**\n * Parses an exponent from a character array.\n *\n * @param chars  the character array containing the exponent\n * @param start  the starting index of the exponent in the character array\n * @return      the parsed exponent value\n */\n",
        "improved_javadoc": "/**\n * Parses an exponent from a character array, assuming it starts at the specified index and continues until the end of the array.\n *\n * @param chars  the character array containing the exponent\n * @param start  the starting index of the exponent in the character array (inclusive)\n * @return      the parsed exponent value as an integer; returns 0 if no valid exponent is found\n */\n"
    },
    {
        "signature": "private void append(final char[] chars)",
        "implementation": "private void append(final char[] chars) {\n        for (final char c : chars) {\n            append(c);\n        }\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "append",
        "javadoc": "/**\n * Appends all characters from the given array to this buffer.\n *\n * @param chars The character array to append.\n */\n",
        "improved_javadoc": "/**\n * Appends all characters in the specified array to this buffer, \n * starting at the given offset and writing up to count characters. \n * If there are more characters in the array than remaining space in this \n * buffer, an attempt will be made to expand capacity of this buffer.\n *\n * @param chars The character array to append from.\n * @param offset The index of the first char to append.\n * @param count  The number of chars to append.\n */\n"
    },
    {
        "signature": "private void appendFraction(final int zeroCount, final int startIdx, final FormatOptions opts)",
        "implementation": "private void appendFraction(final int zeroCount, final int startIdx, final FormatOptions opts) {\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n\n        if (startIdx < digitCount) {\n            append(opts.getDecimalSeparator());\n\n            // add the zero prefix\n            for (int i = 0; i < zeroCount; ++i) {\n                append(localizedZero);\n            }\n\n            // add the fraction digits\n            for (int i = startIdx; i < digitCount; ++i) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n            }\n        } else if (opts.isIncludeFractionPlaceholder()) {\n            append(opts.getDecimalSeparator());\n            append(localizedZero);\n        }\n    }",
        "called_methods": [
            "getDigits",
            "append",
            "getDecimalSeparator",
            "appendLocalizedDigit",
            "isIncludeFractionPlaceholder"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendFraction",
        "javadoc": "/**\n * Appends a fraction to the formatted number.\n *\n * @param zeroCount  The number of leading zeros to include in the fraction.\n * @param startIdx   The starting index of the fraction digits in the {@code digits} array.\n * @param opts       The format options for this operation.\n */\n",
        "improved_javadoc": "/**\n * Appends a fraction to the formatted number, inserting leading zeros as necessary based on the provided count.\n *\n * @param zeroCount  The minimum number of leading zeros to include in the fraction. If the actual number of leading zeros required is greater than this value, they will be inserted accordingly.\n * @param startIdx   The starting index (inclusive) of the fraction digits within the {@code digits} array. This index should point to the first digit of the numerator or denominator.\n * @param opts       The format options for this operation, which may include settings such as decimal separator, thousand separators, and other formatting preferences.\n */\n"
    },
    {
        "signature": "private void appendLocalizedDigit(final int n, final char[] digitChars)",
        "implementation": "private void appendLocalizedDigit(final int n, final char[] digitChars) {\n        append(digitChars[n]);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendLocalizedDigit",
        "javadoc": "/**\n * Appends a localized digit to the current buffer.\n *\n * @param n the index of the digit in the {@code digitChars} array\n * @param digitChars an array containing the localized digits\n */\n",
        "improved_javadoc": "/**\n * Appends a localized digit to the current buffer at the specified position.\n *\n * @param n        the index of the digit in the {@code digitChars} array\n * @param digitChars an array containing the localized digits\n */\n"
    },
    {
        "signature": "private int appendWhole(final int wholeCount, final FormatOptions opts)",
        "implementation": "private int appendWhole(final int wholeCount, final FormatOptions opts) {\n        if (shouldIncludeMinus(opts)) {\n            append(opts.getMinusSign());\n        }\n\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n\n        final int significantDigitCount = Math.max(0, Math.min(wholeCount, digitCount));\n\n        if (significantDigitCount > 0) {\n            int i;\n            for (i = 0; i < significantDigitCount; ++i) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n            }\n\n            for (; i < wholeCount; ++i) {\n                append(localizedZero);\n            }\n        } else {\n            append(localizedZero);\n        }\n\n        return significantDigitCount;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "append",
            "getMinusSign",
            "getDigits",
            "max",
            "min",
            "appendLocalizedDigit"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendWhole",
        "javadoc": "/**\n * Appends a whole number to the output, taking into account the specified format options.\n *\n * @param wholeCount  The number of digits in the whole part of the number.\n * @param opts        The format options to use when appending the whole number.\n * @return            The number of significant digits in the whole part of the number.\n * @throws Exception  If an error occurs while appending the whole number.\n */\n",
        "improved_javadoc": "INVALID FORMAT"
    },
    {
        "signature": "private int appendWholeGrouped(final int wholeCount, final FormatOptions opts)",
        "implementation": "private int appendWholeGrouped(final int wholeCount, final FormatOptions opts) {\n        if (shouldIncludeMinus(opts)) {\n            append(opts.getMinusSign());\n        }\n\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n        final char groupingChar = opts.getGroupingSeparator();\n\n        final int appendCount = Math.max(0, Math.min(wholeCount, digitCount));\n\n        if (appendCount > 0) {\n            int i;\n            int pos = wholeCount;\n            for (i = 0; i < appendCount; ++i, --pos) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n                if (requiresGroupingSeparatorAfterPosition(pos)) {\n                    append(groupingChar);\n                }\n            }\n\n            for (; i < wholeCount; ++i, --pos) {\n                append(localizedZero);\n                if (requiresGroupingSeparatorAfterPosition(pos)) {\n                    append(groupingChar);\n                }\n            }\n        } else {\n            append(localizedZero);\n        }\n\n        return appendCount;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "append",
            "getMinusSign",
            "getDigits",
            "getGroupingSeparator",
            "max",
            "min",
            "appendLocalizedDigit",
            "requiresGroupingSeparatorAfterPosition"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendWholeGrouped",
        "javadoc": "/**\n * Appends a whole number to the output, grouped according to the specified format options.\n *\n * @param wholeCount  The whole part of the number to be appended.\n * @param opts        The format options to use when appending the number.\n * @return            The number of digits that were actually appended.\n * @throws Exception  If an error occurs while appending the number (this should not happen in normal operation).\n */\n",
        "improved_javadoc": "/**\n * Appends the specified whole count to the output, formatted according to the provided options.\n *\n * The formatting options determine how the whole count is grouped and displayed. This method returns\n * the number of digits that were actually appended to the output.\n *\n * @param wholeCount  The whole part of the number to be appended (a non-negative integer).\n * @param opts        The format options to use when appending the number, such as grouping separators and decimal places.\n * @return            The number of digits that were actually appended to the output.\n */\n"
    },
    {
        "signature": "private int getDigitStringSize(final int decimalPos, final FormatOptions opts)",
        "implementation": "private int getDigitStringSize(final int decimalPos, final FormatOptions opts) {\n        int size = digitCount;\n        if (shouldIncludeMinus(opts)) {\n            ++size;\n        }\n        if (decimalPos < 1) {\n            // no whole component;\n            // add decimal point and leading zeros\n            size += 2 + Math.abs(decimalPos);\n        } else if (decimalPos >= digitCount) {\n            // no fraction component;\n            // add trailing zeros\n            size += decimalPos - digitCount;\n            if (opts.isIncludeFractionPlaceholder()) {\n                size += 2;\n            }\n        } else {\n            // whole and fraction components;\n            // add decimal point\n            size += 1;\n        }\n\n        return size;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "abs",
            "isIncludeFractionPlaceholder"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getDigitStringSize",
        "javadoc": "/**\n * Calculates the size of a digit string based on the specified format options.\n *\n * @param decimalPos the position of the decimal point in the number, where 0 indicates no decimal point and negative values indicate leading zeros\n * @param opts the format options to use when calculating the size\n * @return the total size of the digit string\n */\n",
        "improved_javadoc": "INVALID FORMAT"
    },
    {
        "signature": "public int getExponent()",
        "implementation": "public int getExponent() {\n        return exponent;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getExponent",
        "javadoc": "/**\n * Returns the current exponent value.\n *\n * @return The current exponent value.\n */\n",
        "improved_javadoc": "/**\n * Retrieves the current exponent value, which represents the power to which the base number should be raised in a mathematical expression.\n *\n * @return The current exponent value as an integer.\n */\n"
    },
    {
        "signature": "private int getPlainStringSize(final int decimalPos, final FormatOptions opts)",
        "implementation": "private int getPlainStringSize(final int decimalPos, final FormatOptions opts) {\n        int size = getDigitStringSize(decimalPos, opts);\n\n        // adjust for groupings if needed\n        if (opts.isGroupThousands() && decimalPos > 0) {\n            size += (decimalPos - 1) / THOUSANDS_GROUP_SIZE;\n        }\n\n        return size;\n    }",
        "called_methods": [
            "getDigitStringSize",
            "isGroupThousands"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getPlainStringSize",
        "javadoc": "/**\n * Calculates the size of a plain string representation.\n *\n * @param decimalPos the position of the decimal point\n * @param opts       the format options to use for calculation\n * @return the calculated size of the plain string representation\n */\n",
        "improved_javadoc": "/**\n * Calculates the size of a plain string representation, taking into account the position of the decimal point and the specified format options.\n *\n * @param decimalPos the position of the decimal point in the number (0 for no decimal point)\n * @param opts       the format options to use for calculation, including precision and rounding mode\n * @return the calculated size of the plain string representation in bytes\n */\n"
    },
    {
        "signature": "public int getScientificExponent()",
        "implementation": "public int getScientificExponent() {\n        return digitCount + exponent - 1;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getScientificExponent",
        "javadoc": "/**\n * Returns the scientific exponent of a number.\n *\n * @return The scientific exponent, calculated as (digit count + exponent - 1).\n */\n",
        "improved_javadoc": "/**\n * Calculates the scientific exponent of a given number based on its digit count and exponent value.\n *\n * @param number the input number for which to calculate the scientific exponent\n * @return The calculated scientific exponent, where the exponent is adjusted by subtracting 1 from the result of (digit count + exponent)\n */\n"
    },
    {
        "signature": "boolean isZero()",
        "implementation": "boolean isZero() {\n        return digits[0] == 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isZero",
        "javadoc": "/**\n * Checks if the number represented by this object is zero.\n *\n * @return true if the number is zero, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether the numeric value of this object is equal to zero.\n *\n * @return  {@code true} if the numeric value is zero; otherwise, {@code false}\n */\n"
    },
    {
        "signature": "public void maxPrecision(final int precision)",
        "implementation": "public void maxPrecision(final int precision) {\n        if (precision > 0 && precision < digitCount) {\n            if (shouldRoundUp(precision)) {\n                roundUp(precision);\n            } else {\n                truncate(precision);\n            }\n        }\n    }",
        "called_methods": [
            "shouldRoundUp",
            "roundUp",
            "truncate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "maxPrecision",
        "javadoc": "/**\n * Sets the maximum number of digits to display, rounding up or truncating as necessary.\n *\n * @param precision The new maximum number of digits to display. Must be greater than 0 and less than the current digit count.\n * @throws IllegalArgumentException if the provided precision is invalid (less than or equal to 0, or not less than the current digit count)\n */\n",
        "improved_javadoc": "/**\n * Sets the maximum number of digits to display, rounding up or truncating as necessary.\n *\n * @param precision The new maximum number of digits to display. Must be a positive integer and must be less than the current digit count.\n * @return This object for method chaining\n * @throws IllegalArgumentException if the provided precision is invalid (less than 1, or not less than the current digit count)\n */\n"
    },
    {
        "signature": "private String outputString()",
        "implementation": "private String outputString() {\n        final String str = String.valueOf(outputChars);\n        outputChars = null;\n        return str;\n    }",
        "called_methods": [
            "valueOf"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "outputString",
        "javadoc": "/**\n * Returns a string representation of the current character buffer.\n *\n * @return A string containing all characters in the buffer, or an empty string if the buffer is empty.\n */\n",
        "improved_javadoc": "/**\n * Returns a string representation of the current character buffer.\n *\n * @return A string containing all characters in the buffer. If the buffer is empty, an empty string is returned.\n */\n"
    },
    {
        "signature": "private void prepareOutput(final int size)",
        "implementation": "private void prepareOutput(final int size) {\n        outputChars = new char[size];\n        outputIdx = 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "prepareOutput",
        "javadoc": "/**\n * Prepares the output buffer for writing characters.\n *\n * @param size The initial size of the output buffer.\n */\n",
        "improved_javadoc": "/**\n * Initializes a new output buffer with the specified capacity, allowing it to hold at least the given number of characters without needing to be resized.\n *\n * @param size The minimum number of characters that the output buffer should be able to hold initially.\n */\n"
    },
    {
        "signature": "private boolean requiresGroupingSeparatorAfterPosition(final int pos)",
        "implementation": "private boolean requiresGroupingSeparatorAfterPosition(final int pos) {\n        return pos > 1 && pos % THOUSANDS_GROUP_SIZE == 1;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "requiresGroupingSeparatorAfterPosition",
        "javadoc": "/**\n * Determines whether a grouping separator should be placed after a given position.\n *\n * @param pos the position to check\n * @return true if a grouping separator is required, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether a grouping separator should be placed after a specified numeric position.\n *\n * This method considers the locale-specific rules for formatting numbers and determines whether a grouping\n * separator (e.g., comma or dot) is required at the given position. The decision is based on the number's\n * magnitude, with separators typically being used to group digits in sets of three (e.g., 1,000,000).\n *\n * @param pos the numeric position to check for a grouping separator\n * @return true if a grouping separator is required at the specified position, false otherwise\n */\n"
    },
    {
        "signature": "public void round(final int roundExponent)",
        "implementation": "public void round(final int roundExponent) {\n        if (roundExponent > exponent) {\n            final int max = digitCount + exponent;\n\n            if (roundExponent < max) {\n                // rounding to a decimal place less than the max; set max precision\n                maxPrecision(max - roundExponent);\n            } else if (roundExponent == max && shouldRoundUp(0)) {\n                // rounding up directly on the max decimal place\n                setSingleDigitValue(1, roundExponent);\n            } else {\n                // change to zero\n                setSingleDigitValue(0, 0);\n            }\n        }\n    }",
        "called_methods": [
            "maxPrecision",
            "shouldRoundUp",
            "setSingleDigitValue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "round",
        "javadoc": "/**\n * Rounds the number to a specified decimal place.\n *\n * @param roundExponent The exponent of the digit to which the number should be rounded.\n */\n",
        "improved_javadoc": "/**\n * Rounds the given number to the specified decimal place, as defined by the exponent.\n *\n * @param roundExponent The power of 10 (e.g., 2 for hundredths, 3 for thousandths) to which the number should be rounded.\n * @return The number rounded to the specified decimal place.\n */\n"
    },
    {
        "signature": "private void roundUp(final int count)",
        "implementation": "private void roundUp(final int count) {\n        int removedDigits = digitCount - count;\n        int i;\n        for (i = count - 1; i >= 0; --i) {\n            final int d = digits[i] + 1;\n\n            if (d < DECIMAL_RADIX) {\n                // value did not carry over; done adding\n                digits[i] = d;\n                break;\n            }\n            // value carried over; the current position is 0\n            // which we will ignore by shortening the digit count\n            ++removedDigits;\n        }\n\n        if (i < 0) {\n            // all values carried over\n            setSingleDigitValue(1, exponent + removedDigits);\n        } else {\n            // values were updated in-place; just need to update the length\n            truncate(digitCount - removedDigits);\n        }\n    }",
        "called_methods": [
            "setSingleDigitValue",
            "truncate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "roundUp",
        "javadoc": "/**\n * Rounds up the given count of digits by adding 1 to each digit from right to left.\n * If a carry over occurs, it is propagated to the next position and the digit count is shortened accordingly.\n *\n * @param count The number of digits to round up.\n */\n",
        "improved_javadoc": "INVALID FORMAT"
    },
    {
        "signature": "private void setSingleDigitValue(final int digit, final int newExponent)",
        "implementation": "private void setSingleDigitValue(final int digit, final int newExponent) {\n        digits[0] = digit;\n        digitCount = 1;\n        exponent = newExponent;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "setSingleDigitValue",
        "javadoc": "/**\n * Sets a single digit value at the specified position in the number.\n *\n * @param digit   the digit to be set (0-9)\n * @param newExponent  the exponent of the number\n */\n",
        "improved_javadoc": "/**\n * Sets a single digit value at the specified position in the number.\n *\n * @param digit   the digit to be set, where 0 represents an empty digit (i.e., no digit) and values 1-9 represent their respective digits\n * @param newExponent  the exponent of the number\n */\n"
    },
    {
        "signature": "private boolean shouldIncludeExponent(final int targetExponent, final FormatOptions opts)",
        "implementation": "private boolean shouldIncludeExponent(final int targetExponent, final FormatOptions opts) {\n        return targetExponent != 0 || opts.isAlwaysIncludeExponent();\n    }",
        "called_methods": [
            "isAlwaysIncludeExponent"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldIncludeExponent",
        "javadoc": "/**\n * Determines whether to include an exponent in a formatted number.\n *\n * @param targetExponent The target exponent value. If this is non-zero, it will be used as the exponent.\n * @param opts           The format options that determine whether to always include the exponent.\n * @return True if the exponent should be included, false otherwise.\n */\n",
        "improved_javadoc": "/**\n * Determines whether to include an exponent in a formatted number based on the target exponent value and\n * format options. If the target exponent is non-zero, it will be used as the exponent; otherwise,\n * the decision to include the exponent depends on the specified format options.\n *\n * @param targetExponent The target exponent value (non-zero if explicitly set).\n * @param opts           The format options that determine whether to always include the exponent.\n * @return True if the exponent should be included, false otherwise.\n */\n"
    },
    {
        "signature": "private boolean shouldIncludeMinus(final FormatOptions opts)",
        "implementation": "private boolean shouldIncludeMinus(final FormatOptions opts) {\n        return negative && (opts.isSignedZero() || !isZero());\n    }",
        "called_methods": [
            "isSignedZero",
            "isZero"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldIncludeMinus",
        "javadoc": "/**\n * Determines whether a minus sign should be included based on the provided format options.\n *\n * @param opts the format options to consider\n * @return true if a minus sign should be included, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether a minus sign should be included in the output based on the specified formatting requirements.\n *\n * @param opts the format options that define the desired output style\n * @return true if a minus sign should be displayed, false to omit it\n */\n"
    },
    {
        "signature": "private boolean shouldRoundUp(final int count)",
        "implementation": "private boolean shouldRoundUp(final int count) {\n        // Round up in the following cases:\n        // 1. The digit after the last digit is greater than 5.\n        // 2. The digit after the last digit is 5 and there are additional (non-zero)\n        //      digits after it.\n        // 3. The digit after the last digit is 5, there are no additional digits afterward,\n        //      and the last digit is odd (half-even rounding).\n        final int digitAfterLast = digits[count];\n\n        return digitAfterLast > ROUND_CENTER || digitAfterLast == ROUND_CENTER\n                && (count < digitCount - 1 || digits[count - 1] % 2 != 0);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldRoundUp",
        "javadoc": "/**\n * Determines whether to round up based on the given count of digits.\n *\n * @param count the index of the last digit in the number, where 0 is the least significant digit\n * @return true if rounding up is required, false otherwise\n */\n",
        "improved_javadoc": "/**\n * Determines whether to round up based on the given count of digits.\n *\n * This method takes into account the position of the last non-zero digit in the number,\n * and returns true if rounding up is required, indicating that the number has trailing zeros.\n *\n * @param count the index of the last non-zero digit in the number (0-based), where 0 indicates the least significant non-zero digit\n * @return true if the number has trailing zeros, false otherwise\n */\n"
    },
    {
        "signature": "public String toEngineeringString(final FormatOptions opts)",
        "implementation": "public String toEngineeringString(final FormatOptions opts) {\n        final int decimalPos = 1 + Math.floorMod(getScientificExponent(), ENG_EXPONENT_MOD);\n        return toScientificString(decimalPos, opts);\n    }",
        "called_methods": [
            "floorMod",
            "getScientificExponent",
            "toScientificString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toEngineeringString",
        "javadoc": "/**\n * Converts a number to an engineering string representation.\n *\n * @param opts The format options to use when generating the string.\n * @return A string representing the number in an engineering notation.\n */\n",
        "improved_javadoc": "/**\n * Converts a number to an engineering string representation, using the specified format options.\n *\n * @param value The number to convert.\n * @param opts  The format options to use when generating the string. For example, precision and decimal separator.\n * @return A string representing the number in an engineering notation (e.g., \"1.23E+02\").\n * @throws IllegalArgumentException if the input number is not a valid numeric value.\n */\n"
    },
    {
        "signature": "public String toPlainString(final FormatOptions opts)",
        "implementation": "public String toPlainString(final FormatOptions opts) {\n        final int decimalPos = digitCount + exponent;\n        final int fractionZeroCount = decimalPos < 1\n                ? Math.abs(decimalPos)\n                : 0;\n\n        prepareOutput(getPlainStringSize(decimalPos, opts));\n\n        final int fractionStartIdx = opts.isGroupThousands()\n                ? appendWholeGrouped(decimalPos, opts)\n                : appendWhole(decimalPos, opts);\n\n        appendFraction(fractionZeroCount, fractionStartIdx, opts);\n\n        return outputString();\n    }",
        "called_methods": [
            "abs",
            "prepareOutput",
            "getPlainStringSize",
            "isGroupThousands",
            "appendWholeGrouped",
            "appendWhole",
            "appendFraction",
            "outputString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toPlainString",
        "javadoc": "/**\n * Converts this number to a plain string representation.\n *\n * @param opts the format options to use when generating the string\n * @return the plain string representation of this number\n */\n",
        "improved_javadoc": "/**\n * Converts this number to a plain string representation, using the specified formatting options.\n *\n * @param opts the format options (e.g. locale, decimal style) to use when generating the string\n * @return the plain string representation of this number in the specified format\n */\n"
    },
    {
        "signature": "private String toScientificString(final int decimalPos, final FormatOptions opts)",
        "implementation": "private String toScientificString(final int decimalPos, final FormatOptions opts) {\n        final int targetExponent = digitCount + exponent - decimalPos;\n        final int absTargetExponent = Math.abs(targetExponent);\n        final boolean includeExponent = shouldIncludeExponent(targetExponent, opts);\n        final boolean negativeExponent = targetExponent < 0;\n\n        // determine the size of the full formatted string, including the number of\n        // characters needed for the exponent digits\n        int size = getDigitStringSize(decimalPos, opts);\n        int exponentDigitCount = 0;\n        if (includeExponent) {\n            exponentDigitCount = absTargetExponent > 0\n                    ? (int) Math.floor(Math.log10(absTargetExponent)) + 1\n                    : 1;\n\n            size += opts.getExponentSeparatorChars().length + exponentDigitCount;\n            if (negativeExponent) {\n                ++size;\n            }\n        }\n\n        prepareOutput(size);\n\n        // append the portion before the exponent field\n        final int fractionStartIdx = appendWhole(decimalPos, opts);\n        appendFraction(0, fractionStartIdx, opts);\n\n        if (includeExponent) {\n            // append the exponent field\n            append(opts.getExponentSeparatorChars());\n\n            if (negativeExponent) {\n                append(opts.getMinusSign());\n            }\n\n            // append the exponent digits themselves; compute the\n            // string representation directly and add it to the output\n            // buffer to avoid the overhead of Integer.toString()\n            final char[] localizedDigits = opts.getDigits();\n            int rem = absTargetExponent;\n            for (int i = size - 1; i >= outputIdx; --i) {\n                outputChars[i] = localizedDigits[rem % DECIMAL_RADIX];\n                rem /= DECIMAL_RADIX;\n            }\n            outputIdx = size;\n        }\n\n        return outputString();\n    }",
        "called_methods": [
            "toScientificString",
            "abs",
            "shouldIncludeExponent",
            "getDigitStringSize",
            "floor",
            "log10",
            "getExponentSeparatorChars",
            "prepareOutput",
            "appendWhole",
            "appendFraction",
            "append",
            "getMinusSign",
            "getDigits",
            "outputString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toScientificString",
        "javadoc": "/**\n * Formats a number as a string in scientific notation.\n *\n * @param decimalPos  The position of the decimal point in the formatted number.\n * @param opts        The format options to use when formatting the number.\n *\n * @return A string representation of the number in scientific notation.\n *\n * @throws Exception If an error occurs during formatting.\n */\n",
        "improved_javadoc": "/**\n * Formats a number as a string in scientific notation, using the specified decimal position and format options.\n *\n * @param decimalPos The position of the decimal point in the formatted number (e.g., 0 for no decimal point, -1 for exponent-only).\n * @param opts       The format options to use when formatting the number, such as precision and rounding mode.\n *\n * @return A string representation of the number in scientific notation, with the specified decimal position and format options applied.\n *\n * @throws NumberFormatException If the input number is not a valid numeric value.\n */\n"
    },
    {
        "signature": "private void truncate(final int count)",
        "implementation": "private void truncate(final int count) {\n        // trim all trailing zero digits, making sure to leave\n        // at least one digit left\n        int nonZeroCount = count;\n        for (int i = count - 1;\n                i > 0 && digits[i] == 0;\n                --i) {\n            --nonZeroCount;\n        }\n        exponent += digitCount - nonZeroCount;\n        digitCount = nonZeroCount;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "truncate",
        "javadoc": "/**\n * Truncates the number to the specified number of digits.\n *\n * @param count The new number of digits. Must be greater than 0.\n */\n",
        "improved_javadoc": "/**\n * Truncates the number to the specified number of significant digits, effectively rounding it to that precision.\n *\n * @param count The new number of significant digits. Must be greater than 0.\n * @return The truncated number as a string.\n * @throws IllegalArgumentException if the count is not greater than 0.\n */\n"
    }
]