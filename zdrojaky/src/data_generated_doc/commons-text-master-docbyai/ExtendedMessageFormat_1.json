[
    {
        "signature": "private void appendQuotedString(final String pattern, final ParsePosition pos,\n            final StringBuilder appendTo)",
        "implementation": "private void appendQuotedString(final String pattern, final ParsePosition pos,\n            final StringBuilder appendTo) {\n        assert pattern.toCharArray()[pos.getIndex()] == QUOTE\n                : \"Quoted string must start with quote character\";\n\n        // handle quote character at the beginning of the string\n        if (appendTo != null) {\n            appendTo.append(QUOTE);\n        }\n        next(pos);\n\n        final int start = pos.getIndex();\n        final char[] c = pattern.toCharArray();\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                if (appendTo != null) {\n                    appendTo.append(c, start, pos.getIndex() - start);\n                }\n                return;\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
        "called_methods": [
            "toCharArray",
            "getIndex",
            "append",
            "next",
            "length"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "appendQuotedString",
        "javadoc": "/**\n * Appends a quoted string to the specified StringBuilder.\n *\n * @param pattern the input string containing the quoted substring\n * @param pos the current parse position in the input string\n * @param appendTo the StringBuilder to which the quoted string will be appended\n */\n"
    },
    {
        "signature": "public final void applyPattern(final String pattern)",
        "implementation": "public final void applyPattern(final String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        final ArrayList<Format> foundFormats = new ArrayList<>();\n        final ArrayList<String> foundDescriptions = new ArrayList<>();\n        final StringBuilder stripCustom = new StringBuilder(pattern.length());\n\n        final ParsePosition pos = new ParsePosition(0);\n        final char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                final int start = pos.getIndex();\n                final int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                if (foundFormats.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (foundDescriptions.size() != fmtCount) {\n                    throw new IllegalArgumentException(\"The validated expression is false\");\n                }\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                //$FALL-THROUGH$\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            final Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3\n            // seems to provide an extra format element:\n            int i = 0;\n            for (final Format f : foundFormats) {\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n                i++;\n            }\n            super.setFormats(origFormats);\n        }\n    }",
        "called_methods": [
            "length",
            "toCharArray",
            "getIndex",
            "appendQuotedString",
            "seekNonWs",
            "readArgumentIndex",
            "next",
            "append",
            "parseFormatDescription",
            "getFormat",
            "add",
            "size",
            "toString",
            "insertFormats",
            "containsElements",
            "getFormats"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "applyPattern",
        "javadoc": "/**\n * Applies a pattern to this message format.\n *\n * @param pattern the pattern to apply, which may contain format elements and quoted strings\n */\n"
    },
    {
        "signature": "private boolean containsElements(final Collection<?> coll)",
        "implementation": "private boolean containsElements(final Collection<?> coll) {\n        if (coll == null || coll.isEmpty()) {\n            return false;\n        }\n        return coll.stream().anyMatch(Objects::nonNull);\n    }",
        "called_methods": [
            "isEmpty",
            "stream",
            "anyMatch"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "containsElements",
        "javadoc": "/**\n * Checks whether a given collection contains any elements.\n *\n * @param coll the collection to check for elements\n * @return true if the collection is not null and contains at least one element, false otherwise\n */\n"
    },
    {
        "signature": "public boolean equals(final Object obj)",
        "implementation": "public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!Objects.equals(getClass(), obj.getClass())) {\n          return false;\n        }\n        final ExtendedMessageFormat rhs = (ExtendedMessageFormat) obj;\n        if (!Objects.equals(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return Objects.equals(registry, rhs.registry);\n    }",
        "called_methods": [
            "equals",
            "getClass"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "equals",
        "javadoc": "/**\n * Indicates whether some other object is \"equal to\" this one.\n *\n * @param obj the reference object with which to compare.\n * @return true if this object is the same as the obj argument; false otherwise.\n * @throws NullPointerException if the specified object is null and this object is an instance of {@code String};\n *         otherwise returns false\n */\n"
    },
    {
        "signature": "private Format getFormat(final String desc)",
        "implementation": "private Format getFormat(final String desc) {\n        if (registry != null) {\n            String name = desc;\n            String args = null;\n            final int i = desc.indexOf(START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            final FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }",
        "called_methods": [
            "indexOf",
            "substring",
            "trim",
            "get",
            "getFormat",
            "getLocale"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "getFormat",
        "javadoc": "/**\n * Retrieves a format from the registry based on the provided description.\n *\n * @param desc the description of the format to retrieve\n * @return the retrieved format, or null if not found\n */\n"
    },
    {
        "signature": "private void getQuotedString(final String pattern, final ParsePosition pos)",
        "implementation": "private void getQuotedString(final String pattern, final ParsePosition pos) {\n        appendQuotedString(pattern, pos, null);\n    }",
        "called_methods": [
            "appendQuotedString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "getQuotedString",
        "javadoc": "/**\n * Appends a quoted string to the buffer.\n *\n * @param pattern The input string to be appended.\n * @param pos     The current position in the input string.\n */\n"
    },
    {
        "signature": "public int hashCode()",
        "implementation": "public int hashCode() {\n        int result = super.hashCode();\n        result = HASH_SEED * result + Objects.hashCode(registry);\n        return HASH_SEED * result + Objects.hashCode(toPattern);\n    }",
        "called_methods": [
            "hashCode"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "hashCode",
        "javadoc": "/**\n * Returns a hash code value for this object.\n *\n * @return  a hash code value for this object\n */\n"
    },
    {
        "signature": "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)",
        "implementation": "private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        final StringBuilder sb = new StringBuilder(pattern.length() * 2);\n        final ParsePosition pos = new ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            final char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, sb);\n                break;\n            case START_FE:\n                depth++;\n                sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));\n                // do not look for custom patterns when they are embedded, e.g. in a choice\n                if (depth == 1) {\n                    fe++;\n                    final String customPattern = customPatterns.get(fe);\n                    if (customPattern != null) {\n                        sb.append(START_FMT).append(customPattern);\n                    }\n                }\n                break;\n            case END_FE:\n                depth--;\n                //$FALL-THROUGH$\n            default:\n                sb.append(c);\n                next(pos);\n            }\n        }\n        return sb.toString();\n    }",
        "called_methods": [
            "containsElements",
            "length",
            "getIndex",
            "charAt",
            "appendQuotedString",
            "append",
            "readArgumentIndex",
            "next",
            "get",
            "toString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "insertFormats",
        "javadoc": "/**\n * Inserts custom formats into a pattern string.\n *\n * This method iterates over the input pattern and inserts custom patterns at the specified format elements (FE).\n * If no custom patterns are provided, the original pattern is returned unchanged.\n *\n * @param pattern the input pattern to modify\n * @param customPatterns a list of custom patterns to insert into the input pattern\n * @return the modified pattern with custom formats inserted\n */\n"
    },
    {
        "signature": "private ParsePosition next(final ParsePosition pos)",
        "implementation": "private ParsePosition next(final ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }",
        "called_methods": [
            "setIndex",
            "getIndex"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "next",
        "javadoc": "/**\n * Advances the position to the next character.\n *\n * @param pos the current parse position\n * @return the updated parse position with its index incremented by one\n */\n"
    },
    {
        "signature": "private String parseFormatDescription(final String pattern, final ParsePosition pos)",
        "implementation": "private String parseFormatDescription(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 1;\n        while (pos.getIndex() < pattern.length()) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                next(pos);\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    return pattern.substring(text, pos.getIndex());\n                }\n                next(pos);\n                break;\n            case QUOTE:\n                getQuotedString(pattern, pos);\n                break;\n            default:\n                next(pos);\n                break;\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }",
        "called_methods": [
            "getIndex",
            "seekNonWs",
            "length",
            "charAt",
            "next",
            "substring",
            "getQuotedString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "parseFormatDescription",
        "javadoc": "/**\n * Parses a format description from the specified pattern, updating the provided ParsePosition.\n *\n * @param pattern the format description to parse\n * @param pos     the ParsePosition to update with the index of the end of the parsed format element\n * @return the parsed format element as a string\n * @throws IllegalArgumentException if an unterminated format element is found at the specified position\n */\n"
    },
    {
        "signature": "private int readArgumentIndex(final String pattern, final ParsePosition pos)",
        "implementation": "private int readArgumentIndex(final String pattern, final ParsePosition pos) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final StringBuilder result = new StringBuilder();\n        boolean error = false;\n        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if (c != START_FMT && c != END_FE) {\n                    error = true;\n                    continue;\n                }\n            }\n            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n                try {\n                    return Integer.parseInt(result.toString());\n                } catch (final NumberFormatException e) { // NOPMD\n                    // we've already ensured only digits, so unless something\n                    // outlandishly large was specified we should be okay.\n                }\n            }\n            error = !Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new IllegalArgumentException(\n                    \"Invalid format argument index at position \" + start + \": \"\n                            + pattern.substring(start, pos.getIndex()));\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated format element at position \" + start);\n    }",
        "called_methods": [
            "getIndex",
            "seekNonWs",
            "length",
            "next",
            "charAt",
            "isWhitespace",
            "parseInt",
            "toString",
            "isDigit",
            "append",
            "substring"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "readArgumentIndex",
        "javadoc": "/**\n * Reads an integer argument index from a format string.\n *\n * This method iterates over the characters in the format string, skipping whitespace and\n * parsing digits until it encounters a non-digit character. If a digit sequence is found,\n * it attempts to parse it as an integer. If successful, the parsed value is returned.\n *\n * @param pattern the format string to read from\n * @param pos the current position in the format string\n * @return the parsed argument index\n * @throws IllegalArgumentException if the format string contains invalid characters or\n *         is not properly terminated\n */\n"
    },
    {
        "signature": "private void seekNonWs(final String pattern, final ParsePosition pos)",
        "implementation": "private void seekNonWs(final String pattern, final ParsePosition pos) {\n        int len = 0;\n        final char[] buffer = pattern.toCharArray();\n        do {\n            len = StringMatcherFactory.INSTANCE.splitMatcher().isMatch(buffer, pos.getIndex(), 0, buffer.length);\n            pos.setIndex(pos.getIndex() + len);\n        } while (len > 0 && pos.getIndex() < pattern.length());\n    }",
        "called_methods": [
            "toCharArray",
            "getIndex",
            "length",
            "splitMatcher",
            "isMatch",
            "setIndex"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "seekNonWs",
        "javadoc": "/**\n * Seeks non-whitespace characters in the provided pattern.\n *\n * This method iterates over the input string, splitting it into substrings based on whitespace characters.\n * It updates the provided ParsePosition object to point to the next non-whitespace character.\n *\n * @param pattern The input string to search for non-whitespace characters.\n * @param pos     The ParsePosition object to update with the index of the next non-whitespace character.\n */\n"
    },
    {
        "signature": "public void setFormat(final int formatElementIndex, final Format newFormat)",
        "implementation": "public void setFormat(final int formatElementIndex, final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "setFormat",
        "javadoc": "/**\n * Sets a new format for the specified element.\n *\n * @param formatElementIndex The index of the element to be formatted (1-based).\n * @param newFormat The new format to apply.\n */\n"
    },
    {
        "signature": "public void setFormatByArgumentIndex(final int argumentIndex,\n                                         final Format newFormat)",
        "implementation": "public void setFormatByArgumentIndex(final int argumentIndex,\n                                         final Format newFormat) {\n        throw new UnsupportedOperationException();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "setFormatByArgumentIndex",
        "javadoc": "/**\n * Sets the format of a field based on its index in the arguments array.\n *\n * @param argumentIndex The index of the field to set the format for.\n * @param newFormat     The new format to apply to the field.\n */\n"
    },
    {
        "signature": "public void setFormats(final Format[] newFormats)",
        "implementation": "public void setFormats(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "setFormats",
        "javadoc": "/**\n * Sets the formats to be used for formatting.\n *\n * @param newFormats an array of {@link Format} objects\n */\n"
    },
    {
        "signature": "public void setFormatsByArgumentIndex(final Format[] newFormats)",
        "implementation": "public void setFormatsByArgumentIndex(final Format[] newFormats) {\n        throw new UnsupportedOperationException();\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "setFormatsByArgumentIndex",
        "javadoc": "/**\n * Sets the formats by argument index.\n *\n * @param newFormats an array of {@link Format} objects to be used for formatting\n *                   arguments in the query string. The length of this array must match\n *                   the number of arguments in the query string.\n */\n"
    },
    {
        "signature": "public String toPattern()",
        "implementation": "public String toPattern() {\n        return toPattern;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\ExtendedMessageFormat.java",
        "name": "toPattern",
        "javadoc": "/**\n * Returns a pattern string representation of this object.\n *\n * @return a pattern string\n */\n"
    }
]