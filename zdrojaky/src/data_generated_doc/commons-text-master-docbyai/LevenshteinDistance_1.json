[
    {
        "signature": "public static LevenshteinDistance getDefaultInstance()",
        "implementation": "public static LevenshteinDistance getDefaultInstance() {\n        return INSTANCE;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "getDefaultInstance",
        "javadoc": "/**\n * Returns the default instance of LevenshteinDistance.\n *\n * @return The default instance of LevenshteinDistance.\n */\n"
    },
    {
        "signature": "private static <E> int limitedCompare(SimilarityInput<E> left, SimilarityInput<E> right, final int threshold)",
        "implementation": "private static <E> int limitedCompare(SimilarityInput<E> left, SimilarityInput<E> right, final int threshold) { // NOPMD\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n\n        /*\n         * This implementation only computes the distance if it's less than or equal to the threshold value, returning -1 if it's greater. The advantage is\n         * performance: unbounded distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only computing a diagonal stripe of width 2k + 1\n         * of the cost table. It is also possible to use this to compute the unbounded Levenshtein distance by starting the threshold at 1 and doubling each\n         * time until the distance is found; this is O(dm), where d is the distance.\n         *\n         * One subtlety comes from needing to ignore entries on the border of our stripe eg. p[] = |#|#|#|* d[] = *|#|#|#| We must ignore the entry to the left\n         * of the leftmost member We must ignore the entry above the rightmost member\n         *\n         * Another subtlety comes from our stripe running off the matrix if the strings aren't of the same size. Since string s is always swapped to be the\n         * shorter of the two, the stripe will always run off to the upper right instead of the lower left of the matrix.\n         *\n         * As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1. In this case we're going to walk a stripe of length 3. The\n         * matrix would look like so:\n         *\n         * <pre> 1 2 3 4 5 1 |#|#| | | | 2 |#|#|#| | | 3 | |#|#|#| | 4 | | |#|#|#| 5 | | | |#|#| 6 | | | | |#| 7 | | | | | | </pre>\n         *\n         * Note how the stripe leads off the table as there is no possible way to turn a string of length 5 into one of length 7 in edit distance of 1.\n         *\n         * Additionally, this implementation decreases memory usage by using two single-dimensional arrays and swapping them back and forth instead of\n         * allocating an entire n by m matrix. This requires a few minor changes, such as immediately returning when it's detected that the stripe has run off\n         * the matrix and initially filling the arrays with large values so that entries we don't compute are ignored.\n         *\n         * See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.\n         */\n\n        int n = left.length(); // length of left\n        int m = right.length(); // length of right\n\n        // if one string is empty, the edit distance is necessarily the length\n        // of the other\n        if (n == 0) {\n            return m <= threshold ? m : -1;\n        }\n        if (m == 0) {\n            return n <= threshold ? n : -1;\n        }\n\n        if (n > m) {\n            // swap the two strings to consume less memory\n            final SimilarityInput<E> tmp = left;\n            left = right;\n            right = tmp;\n            n = m;\n            m = right.length();\n        }\n\n        // the edit distance cannot be less than the length difference\n        if (m - n > threshold) {\n            return -1;\n        }\n\n        int[] p = new int[n + 1]; // 'previous' cost array, horizontally\n        int[] d = new int[n + 1]; // cost array, horizontally\n        int[] tempD; // placeholder to assist in swapping p and d\n\n        // fill in starting table values\n        final int boundary = Math.min(n, threshold) + 1;\n        for (int i = 0; i < boundary; i++) {\n            p[i] = i;\n        }\n        // these fills ensure that the value above the rightmost entry of our\n        // stripe will be ignored in following loop iterations\n        Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);\n        Arrays.fill(d, Integer.MAX_VALUE);\n\n        // iterates through t\n        for (int j = 1; j <= m; j++) {\n            final E rightJ = right.at(j - 1); // jth character of right\n            d[0] = j;\n\n            // compute stripe indices, constrain to array size\n            final int min = Math.max(1, j - threshold);\n            final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);\n\n            // ignore entry left of leftmost\n            if (min > 1) {\n                d[min - 1] = Integer.MAX_VALUE;\n            }\n\n            int lowerBound = Integer.MAX_VALUE;\n            // iterates through [min, max] in s\n            for (int i = min; i <= max; i++) {\n                if (left.at(i - 1).equals(rightJ)) {\n                    // diagonally left and up\n                    d[i] = p[i - 1];\n                } else {\n                    // 1 + minimum of cell to the left, to the top, diagonally\n                    // left and up\n                    d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n                }\n                lowerBound = Math.min(lowerBound, d[i]);\n            }\n            // if the lower bound is greater than the threshold, then exit early\n            if (lowerBound > threshold) {\n                return -1;\n            }\n\n            // copy current distance counts to 'previous row' distance counts\n            tempD = p;\n            p = d;\n            d = tempD;\n        }\n\n        // if p[n] is greater than the threshold, there's no guarantee on it\n        // being the correct\n        // distance\n        if (p[n] <= threshold) {\n            return p[n];\n        }\n        return -1;\n    }",
        "called_methods": [
            "length",
            "min",
            "fill",
            "at",
            "max",
            "equals"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "limitedCompare",
        "javadoc": "/**\n * Computes a limited edit distance between two strings, returning -1 if it exceeds the given threshold.\n *\n * This implementation uses dynamic programming to efficiently compute the edit distance within a bounded range. It is designed to handle large input strings by only computing a diagonal stripe of width 2k + 1 of the cost table, where k is the threshold value.\n *\n * @param left    The first string\n * @param right   The second string\n * @param threshold The maximum allowed edit distance (must be non-negative)\n * @return The limited edit distance between the two strings if it does not exceed the threshold; -1 otherwise\n * @throws IllegalArgumentException If either input string is null or the threshold value is negative\n */\n"
    },
    {
        "signature": "private static <E> int unlimitedCompare(SimilarityInput<E> left, SimilarityInput<E> right)",
        "implementation": "private static <E> int unlimitedCompare(SimilarityInput<E> left, SimilarityInput<E> right) {\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n        /*\n         * This implementation use two variable to record the previous cost counts, So this implementation use less memory than previous impl.\n         */\n        int n = left.length(); // length of left\n        int m = right.length(); // length of right\n\n        if (n == 0) {\n            return m;\n        }\n        if (m == 0) {\n            return n;\n        }\n        if (n > m) {\n            // swap the input strings to consume less memory\n            final SimilarityInput<E> tmp = left;\n            left = right;\n            right = tmp;\n            n = m;\n            m = right.length();\n        }\n        final int[] p = new int[n + 1];\n        // indexes into strings left and right\n        int i; // iterates through left\n        int j; // iterates through right\n        int upperLeft;\n        int upper;\n        E rightJ; // jth character of right\n        int cost; // cost\n        for (i = 0; i <= n; i++) {\n            p[i] = i;\n        }\n        for (j = 1; j <= m; j++) {\n            upperLeft = p[0];\n            rightJ = right.at(j - 1);\n            p[0] = j;\n\n            for (i = 1; i <= n; i++) {\n                upper = p[i];\n                cost = left.at(i - 1).equals(rightJ) ? 0 : 1;\n                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n                p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upperLeft + cost);\n                upperLeft = upper;\n            }\n        }\n        return p[n];\n    }",
        "called_methods": [
            "length",
            "at",
            "equals",
            "min"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "unlimitedCompare",
        "javadoc": "/**\n * Compares two SimilarityInput objects without any limit on the number of operations.\n *\n * This implementation uses dynamic programming to efficiently compute the edit distance between the two input sequences.\n * It has a time complexity of O(n*m), where n and m are the lengths of the input sequences.\n *\n * @param left  The first SimilarityInput object to compare\n * @param right The second SimilarityInput object to compare\n * @return      The edit distance between the two input sequences\n * @throws IllegalArgumentException if either of the input objects is null\n */\n"
    },
    {
        "signature": "public <E> Integer apply(final SimilarityInput<E> left, final SimilarityInput<E> right)",
        "implementation": "public <E> Integer apply(final SimilarityInput<E> left, final SimilarityInput<E> right) {\n        if (threshold != null) {\n            return limitedCompare(left, right, threshold);\n        }\n        return unlimitedCompare(left, right);\n    }",
        "called_methods": [
            "apply",
            "input",
            "limitedCompare",
            "unlimitedCompare"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "apply",
        "javadoc": "/**\n * Applies the similarity comparison between two input objects.\n *\n * @param left  The first input object to compare.\n * @param right The second input object to compare.\n * @return An integer value representing the result of the comparison. \n *         A negative integer indicates that the first input is less similar, \n *         zero indicates they are equal in similarity, and a positive integer \n *         indicates that the first input is more similar.\n */\n"
    },
    {
        "signature": "public Integer getThreshold()",
        "implementation": "public Integer getThreshold() {\n        return threshold;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\similarity\\LevenshteinDistance.java",
        "name": "getThreshold",
        "javadoc": "/**\n * Returns the current threshold value.\n *\n * @return The current threshold value as an Integer, or null if no threshold has been set.\n */\n"
    }
]