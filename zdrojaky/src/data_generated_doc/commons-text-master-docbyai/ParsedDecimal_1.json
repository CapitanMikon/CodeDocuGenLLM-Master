[
    {
        "signature": "char getMinusSign();\n\n        /**\n         * Return",
        "implementation": "char getMinusSign();\n\n        /**\n         * Return {@code true} if exponent values should always be included in",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getMinusSign",
        "javadoc": "/**\n * Returns the minus sign character.\n *\n * @return the minus sign character\n */\n"
    },
    {
        "signature": "boolean isAlwaysIncludeExponent();\n\n        /**\n         * Return",
        "implementation": "boolean isAlwaysIncludeExponent();\n\n        /**\n         * Return {@code true} if thousands should be grouped.",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isAlwaysIncludeExponent",
        "javadoc": "/**\n * Returns {@code true} if an exponent should always be included.\n *\n * @return {@code true} if an exponent should always be included, otherwise {@code false}\n */\n"
    },
    {
        "signature": "boolean isGroupThousands();\n\n        /**\n         * Return",
        "implementation": "boolean isGroupThousands();\n\n        /**\n         * Return {@code true} if fraction placeholders (e.g., {@code \".0\"} in {@code \"1.0\"})",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isGroupThousands",
        "javadoc": "/**\n * Returns whether group thousands are enabled.\n *\n * @return true if group thousands are enabled, false otherwise\n */\n"
    },
    {
        "signature": "boolean isIncludeFractionPlaceholder();\n\n        /**\n         * Return",
        "implementation": "boolean isIncludeFractionPlaceholder();\n\n        /**\n         * Return {@code true} if the string zero should be prefixed with the minus sign",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isIncludeFractionPlaceholder",
        "javadoc": "/**\n * Returns whether the include fraction placeholder is present.\n *\n * @return true if the include fraction placeholder is present, false otherwise\n */\n"
    },
    {
        "signature": "private static int digitValue(final char ch)",
        "implementation": "private static int digitValue(final char ch) {\n        return ch - ZERO_CHAR;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "digitValue",
        "javadoc": "/**\n * Returns the numeric value of a digit character.\n *\n * @param ch the digit character to be converted\n * @return the numeric value of the digit character (0-9)\n */\n"
    },
    {
        "signature": "public static ParsedDecimal from(final double d)",
        "implementation": "public static ParsedDecimal from(final double d) {\n        if (!Double.isFinite(d)) {\n            throw new IllegalArgumentException(\"Double is not finite\");\n        }\n\n        // Get the canonical string representation of the double value and parse\n        // it to extract the components of the decimal value. From the documentation\n        // of Double.toString() and the fact that d is finite, we are guaranteed the\n        // following:\n        // - the string will not be empty\n        // - it will contain exactly one decimal point character\n        // - all digit characters are in the ASCII range\n        final char[] strChars = Double.toString(d).toCharArray();\n\n        final boolean negative = strChars[0] == MINUS_CHAR;\n        final int digitStartIdx = negative ? 1 : 0;\n\n        final int[] digits = new int[strChars.length - digitStartIdx - 1];\n\n        boolean foundDecimalPoint = false;\n        int digitCount = 0;\n        int significantDigitCount = 0;\n        int decimalPos = 0;\n\n        int i;\n        for (i = digitStartIdx; i < strChars.length; ++i) {\n            final char ch = strChars[i];\n\n            if (ch == DECIMAL_SEP_CHAR) {\n                foundDecimalPoint = true;\n                decimalPos = digitCount;\n            } else if (ch == EXPONENT_CHAR) {\n                // no more mantissa digits\n                break;\n            } else if (ch != ZERO_CHAR || digitCount > 0) {\n                // this is either the first non-zero digit or one after it\n                final int val = digitValue(ch);\n                digits[digitCount++] = val;\n\n                if (val > 0) {\n                    significantDigitCount = digitCount;\n                }\n            } else if (foundDecimalPoint) {\n                // leading zero in a fraction; adjust the decimal position\n                --decimalPos;\n            }\n        }\n\n        if (digitCount > 0) {\n            // determine the exponent\n            final int explicitExponent = i < strChars.length\n                    ? parseExponent(strChars, i + 1)\n                    : 0;\n            final int exponent = explicitExponent + decimalPos - significantDigitCount;\n\n            return new ParsedDecimal(negative, digits, significantDigitCount, exponent);\n        }\n\n        // no non-zero digits, so value is zero\n        return new ParsedDecimal(negative, new int[] {0}, 1, 0);\n    }",
        "called_methods": [
            "isFinite",
            "toString",
            "toCharArray",
            "digitValue",
            "parseExponent"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "from",
        "javadoc": "/**\n * Creates a parsed decimal from a double value.\n *\n * @param d the double value to parse\n * @return a parsed decimal representation of the input value\n * @throws IllegalArgumentException if the input double is not finite\n */\n"
    },
    {
        "signature": "private static int parseExponent(final char[] chars, final int start)",
        "implementation": "private static int parseExponent(final char[] chars, final int start) {\n        int i = start;\n        final boolean neg = chars[i] == MINUS_CHAR;\n        if (neg) {\n            ++i;\n        }\n\n        int exp = 0;\n        for (; i < chars.length; ++i) {\n            exp = exp * DECIMAL_RADIX + digitValue(chars[i]);\n        }\n\n        return neg ? -exp : exp;\n    }",
        "called_methods": [
            "digitValue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "parseExponent",
        "javadoc": "/**\n * Parses an exponent from a character array.\n *\n * @param chars  the character array containing the exponent\n * @param start  the starting index of the exponent in the character array\n * @return      the parsed exponent value\n */\n"
    },
    {
        "signature": "private void append(final char[] chars)",
        "implementation": "private void append(final char[] chars) {\n        for (final char c : chars) {\n            append(c);\n        }\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "append",
        "javadoc": "/**\n * Appends all characters from the given array to this buffer.\n *\n * @param chars The character array to append.\n */\n"
    },
    {
        "signature": "private void appendFraction(final int zeroCount, final int startIdx, final FormatOptions opts)",
        "implementation": "private void appendFraction(final int zeroCount, final int startIdx, final FormatOptions opts) {\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n\n        if (startIdx < digitCount) {\n            append(opts.getDecimalSeparator());\n\n            // add the zero prefix\n            for (int i = 0; i < zeroCount; ++i) {\n                append(localizedZero);\n            }\n\n            // add the fraction digits\n            for (int i = startIdx; i < digitCount; ++i) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n            }\n        } else if (opts.isIncludeFractionPlaceholder()) {\n            append(opts.getDecimalSeparator());\n            append(localizedZero);\n        }\n    }",
        "called_methods": [
            "getDigits",
            "append",
            "getDecimalSeparator",
            "appendLocalizedDigit",
            "isIncludeFractionPlaceholder"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendFraction",
        "javadoc": "/**\n * Appends a fraction to the formatted number.\n *\n * @param zeroCount  The number of leading zeros to include in the fraction.\n * @param startIdx   The starting index of the fraction digits in the {@code digits} array.\n * @param opts       The format options for this operation.\n */\n"
    },
    {
        "signature": "private void appendLocalizedDigit(final int n, final char[] digitChars)",
        "implementation": "private void appendLocalizedDigit(final int n, final char[] digitChars) {\n        append(digitChars[n]);\n    }",
        "called_methods": [
            "append"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendLocalizedDigit",
        "javadoc": "/**\n * Appends a localized digit to the current buffer.\n *\n * @param n the index of the digit in the {@code digitChars} array\n * @param digitChars an array containing the localized digits\n */\n"
    },
    {
        "signature": "private int appendWhole(final int wholeCount, final FormatOptions opts)",
        "implementation": "private int appendWhole(final int wholeCount, final FormatOptions opts) {\n        if (shouldIncludeMinus(opts)) {\n            append(opts.getMinusSign());\n        }\n\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n\n        final int significantDigitCount = Math.max(0, Math.min(wholeCount, digitCount));\n\n        if (significantDigitCount > 0) {\n            int i;\n            for (i = 0; i < significantDigitCount; ++i) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n            }\n\n            for (; i < wholeCount; ++i) {\n                append(localizedZero);\n            }\n        } else {\n            append(localizedZero);\n        }\n\n        return significantDigitCount;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "append",
            "getMinusSign",
            "getDigits",
            "max",
            "min",
            "appendLocalizedDigit"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendWhole",
        "javadoc": "/**\n * Appends a whole number to the output, taking into account the specified format options.\n *\n * @param wholeCount  The number of digits in the whole part of the number.\n * @param opts        The format options to use when appending the whole number.\n * @return            The number of significant digits in the whole part of the number.\n * @throws Exception  If an error occurs while appending the whole number.\n */\n"
    },
    {
        "signature": "private int appendWholeGrouped(final int wholeCount, final FormatOptions opts)",
        "implementation": "private int appendWholeGrouped(final int wholeCount, final FormatOptions opts) {\n        if (shouldIncludeMinus(opts)) {\n            append(opts.getMinusSign());\n        }\n\n        final char[] localizedDigits = opts.getDigits();\n        final char localizedZero = localizedDigits[0];\n        final char groupingChar = opts.getGroupingSeparator();\n\n        final int appendCount = Math.max(0, Math.min(wholeCount, digitCount));\n\n        if (appendCount > 0) {\n            int i;\n            int pos = wholeCount;\n            for (i = 0; i < appendCount; ++i, --pos) {\n                appendLocalizedDigit(digits[i], localizedDigits);\n                if (requiresGroupingSeparatorAfterPosition(pos)) {\n                    append(groupingChar);\n                }\n            }\n\n            for (; i < wholeCount; ++i, --pos) {\n                append(localizedZero);\n                if (requiresGroupingSeparatorAfterPosition(pos)) {\n                    append(groupingChar);\n                }\n            }\n        } else {\n            append(localizedZero);\n        }\n\n        return appendCount;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "append",
            "getMinusSign",
            "getDigits",
            "getGroupingSeparator",
            "max",
            "min",
            "appendLocalizedDigit",
            "requiresGroupingSeparatorAfterPosition"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "appendWholeGrouped",
        "javadoc": "/**\n * Appends a whole number to the output, grouped according to the specified format options.\n *\n * @param wholeCount  The whole part of the number to be appended.\n * @param opts        The format options to use when appending the number.\n * @return            The number of digits that were actually appended.\n * @throws Exception  If an error occurs while appending the number (this should not happen in normal operation).\n */\n"
    },
    {
        "signature": "private int getDigitStringSize(final int decimalPos, final FormatOptions opts)",
        "implementation": "private int getDigitStringSize(final int decimalPos, final FormatOptions opts) {\n        int size = digitCount;\n        if (shouldIncludeMinus(opts)) {\n            ++size;\n        }\n        if (decimalPos < 1) {\n            // no whole component;\n            // add decimal point and leading zeros\n            size += 2 + Math.abs(decimalPos);\n        } else if (decimalPos >= digitCount) {\n            // no fraction component;\n            // add trailing zeros\n            size += decimalPos - digitCount;\n            if (opts.isIncludeFractionPlaceholder()) {\n                size += 2;\n            }\n        } else {\n            // whole and fraction components;\n            // add decimal point\n            size += 1;\n        }\n\n        return size;\n    }",
        "called_methods": [
            "shouldIncludeMinus",
            "abs",
            "isIncludeFractionPlaceholder"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getDigitStringSize",
        "javadoc": "/**\n * Calculates the size of a digit string based on the specified format options.\n *\n * @param decimalPos the position of the decimal point in the number, where 0 indicates no decimal point and negative values indicate leading zeros\n * @param opts the format options to use when calculating the size\n * @return the total size of the digit string\n */\n"
    },
    {
        "signature": "public int getExponent()",
        "implementation": "public int getExponent() {\n        return exponent;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getExponent",
        "javadoc": "/**\n * Returns the current exponent value.\n *\n * @return The current exponent value.\n */\n"
    },
    {
        "signature": "private int getPlainStringSize(final int decimalPos, final FormatOptions opts)",
        "implementation": "private int getPlainStringSize(final int decimalPos, final FormatOptions opts) {\n        int size = getDigitStringSize(decimalPos, opts);\n\n        // adjust for groupings if needed\n        if (opts.isGroupThousands() && decimalPos > 0) {\n            size += (decimalPos - 1) / THOUSANDS_GROUP_SIZE;\n        }\n\n        return size;\n    }",
        "called_methods": [
            "getDigitStringSize",
            "isGroupThousands"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getPlainStringSize",
        "javadoc": "/**\n * Calculates the size of a plain string representation.\n *\n * @param decimalPos the position of the decimal point\n * @param opts       the format options to use for calculation\n * @return the calculated size of the plain string representation\n */\n"
    },
    {
        "signature": "public int getScientificExponent()",
        "implementation": "public int getScientificExponent() {\n        return digitCount + exponent - 1;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "getScientificExponent",
        "javadoc": "/**\n * Returns the scientific exponent of a number.\n *\n * @return The scientific exponent, calculated as (digit count + exponent - 1).\n */\n"
    },
    {
        "signature": "boolean isZero()",
        "implementation": "boolean isZero() {\n        return digits[0] == 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "isZero",
        "javadoc": "/**\n * Checks if the number represented by this object is zero.\n *\n * @return true if the number is zero, false otherwise\n */\n"
    },
    {
        "signature": "public void maxPrecision(final int precision)",
        "implementation": "public void maxPrecision(final int precision) {\n        if (precision > 0 && precision < digitCount) {\n            if (shouldRoundUp(precision)) {\n                roundUp(precision);\n            } else {\n                truncate(precision);\n            }\n        }\n    }",
        "called_methods": [
            "shouldRoundUp",
            "roundUp",
            "truncate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "maxPrecision",
        "javadoc": "/**\n * Sets the maximum number of digits to display, rounding up or truncating as necessary.\n *\n * @param precision The new maximum number of digits to display. Must be greater than 0 and less than the current digit count.\n * @throws IllegalArgumentException if the provided precision is invalid (less than or equal to 0, or not less than the current digit count)\n */\n"
    },
    {
        "signature": "private String outputString()",
        "implementation": "private String outputString() {\n        final String str = String.valueOf(outputChars);\n        outputChars = null;\n        return str;\n    }",
        "called_methods": [
            "valueOf"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "outputString",
        "javadoc": "/**\n * Returns a string representation of the current character buffer.\n *\n * @return A string containing all characters in the buffer, or an empty string if the buffer is empty.\n */\n"
    },
    {
        "signature": "private void prepareOutput(final int size)",
        "implementation": "private void prepareOutput(final int size) {\n        outputChars = new char[size];\n        outputIdx = 0;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "prepareOutput",
        "javadoc": "/**\n * Prepares the output buffer for writing characters.\n *\n * @param size The initial size of the output buffer.\n */\n"
    },
    {
        "signature": "private boolean requiresGroupingSeparatorAfterPosition(final int pos)",
        "implementation": "private boolean requiresGroupingSeparatorAfterPosition(final int pos) {\n        return pos > 1 && pos % THOUSANDS_GROUP_SIZE == 1;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "requiresGroupingSeparatorAfterPosition",
        "javadoc": "/**\n * Determines whether a grouping separator should be placed after a given position.\n *\n * @param pos the position to check\n * @return true if a grouping separator is required, false otherwise\n */\n"
    },
    {
        "signature": "public void round(final int roundExponent)",
        "implementation": "public void round(final int roundExponent) {\n        if (roundExponent > exponent) {\n            final int max = digitCount + exponent;\n\n            if (roundExponent < max) {\n                // rounding to a decimal place less than the max; set max precision\n                maxPrecision(max - roundExponent);\n            } else if (roundExponent == max && shouldRoundUp(0)) {\n                // rounding up directly on the max decimal place\n                setSingleDigitValue(1, roundExponent);\n            } else {\n                // change to zero\n                setSingleDigitValue(0, 0);\n            }\n        }\n    }",
        "called_methods": [
            "maxPrecision",
            "shouldRoundUp",
            "setSingleDigitValue"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "round",
        "javadoc": "/**\n * Rounds the number to a specified decimal place.\n *\n * @param roundExponent The exponent of the digit to which the number should be rounded.\n */\n"
    },
    {
        "signature": "private void roundUp(final int count)",
        "implementation": "private void roundUp(final int count) {\n        int removedDigits = digitCount - count;\n        int i;\n        for (i = count - 1; i >= 0; --i) {\n            final int d = digits[i] + 1;\n\n            if (d < DECIMAL_RADIX) {\n                // value did not carry over; done adding\n                digits[i] = d;\n                break;\n            }\n            // value carried over; the current position is 0\n            // which we will ignore by shortening the digit count\n            ++removedDigits;\n        }\n\n        if (i < 0) {\n            // all values carried over\n            setSingleDigitValue(1, exponent + removedDigits);\n        } else {\n            // values were updated in-place; just need to update the length\n            truncate(digitCount - removedDigits);\n        }\n    }",
        "called_methods": [
            "setSingleDigitValue",
            "truncate"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "roundUp",
        "javadoc": "/**\n * Rounds up the given count of digits by adding 1 to each digit from right to left.\n * If a carry over occurs, it is propagated to the next position and the digit count is shortened accordingly.\n *\n * @param count The number of digits to round up.\n */\n"
    },
    {
        "signature": "private void setSingleDigitValue(final int digit, final int newExponent)",
        "implementation": "private void setSingleDigitValue(final int digit, final int newExponent) {\n        digits[0] = digit;\n        digitCount = 1;\n        exponent = newExponent;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "setSingleDigitValue",
        "javadoc": "/**\n * Sets a single digit value at the specified position in the number.\n *\n * @param digit   the digit to be set (0-9)\n * @param newExponent  the exponent of the number\n */\n"
    },
    {
        "signature": "private boolean shouldIncludeExponent(final int targetExponent, final FormatOptions opts)",
        "implementation": "private boolean shouldIncludeExponent(final int targetExponent, final FormatOptions opts) {\n        return targetExponent != 0 || opts.isAlwaysIncludeExponent();\n    }",
        "called_methods": [
            "isAlwaysIncludeExponent"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldIncludeExponent",
        "javadoc": "/**\n * Determines whether to include an exponent in a formatted number.\n *\n * @param targetExponent The target exponent value. If this is non-zero, it will be used as the exponent.\n * @param opts           The format options that determine whether to always include the exponent.\n * @return True if the exponent should be included, false otherwise.\n */\n"
    },
    {
        "signature": "private boolean shouldIncludeMinus(final FormatOptions opts)",
        "implementation": "private boolean shouldIncludeMinus(final FormatOptions opts) {\n        return negative && (opts.isSignedZero() || !isZero());\n    }",
        "called_methods": [
            "isSignedZero",
            "isZero"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldIncludeMinus",
        "javadoc": "/**\n * Determines whether a minus sign should be included based on the provided format options.\n *\n * @param opts the format options to consider\n * @return true if a minus sign should be included, false otherwise\n */\n"
    },
    {
        "signature": "private boolean shouldRoundUp(final int count)",
        "implementation": "private boolean shouldRoundUp(final int count) {\n        // Round up in the following cases:\n        // 1. The digit after the last digit is greater than 5.\n        // 2. The digit after the last digit is 5 and there are additional (non-zero)\n        //      digits after it.\n        // 3. The digit after the last digit is 5, there are no additional digits afterward,\n        //      and the last digit is odd (half-even rounding).\n        final int digitAfterLast = digits[count];\n\n        return digitAfterLast > ROUND_CENTER || digitAfterLast == ROUND_CENTER\n                && (count < digitCount - 1 || digits[count - 1] % 2 != 0);\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "shouldRoundUp",
        "javadoc": "/**\n * Determines whether to round up based on the given count of digits.\n *\n * @param count the index of the last digit in the number, where 0 is the least significant digit\n * @return true if rounding up is required, false otherwise\n */\n"
    },
    {
        "signature": "public String toEngineeringString(final FormatOptions opts)",
        "implementation": "public String toEngineeringString(final FormatOptions opts) {\n        final int decimalPos = 1 + Math.floorMod(getScientificExponent(), ENG_EXPONENT_MOD);\n        return toScientificString(decimalPos, opts);\n    }",
        "called_methods": [
            "floorMod",
            "getScientificExponent",
            "toScientificString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toEngineeringString",
        "javadoc": "/**\n * Converts a number to an engineering string representation.\n *\n * @param opts The format options to use when generating the string.\n * @return A string representing the number in an engineering notation.\n */\n"
    },
    {
        "signature": "public String toPlainString(final FormatOptions opts)",
        "implementation": "public String toPlainString(final FormatOptions opts) {\n        final int decimalPos = digitCount + exponent;\n        final int fractionZeroCount = decimalPos < 1\n                ? Math.abs(decimalPos)\n                : 0;\n\n        prepareOutput(getPlainStringSize(decimalPos, opts));\n\n        final int fractionStartIdx = opts.isGroupThousands()\n                ? appendWholeGrouped(decimalPos, opts)\n                : appendWhole(decimalPos, opts);\n\n        appendFraction(fractionZeroCount, fractionStartIdx, opts);\n\n        return outputString();\n    }",
        "called_methods": [
            "abs",
            "prepareOutput",
            "getPlainStringSize",
            "isGroupThousands",
            "appendWholeGrouped",
            "appendWhole",
            "appendFraction",
            "outputString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toPlainString",
        "javadoc": "/**\n * Converts this number to a plain string representation.\n *\n * @param opts the format options to use when generating the string\n * @return the plain string representation of this number\n */\n"
    },
    {
        "signature": "private String toScientificString(final int decimalPos, final FormatOptions opts)",
        "implementation": "private String toScientificString(final int decimalPos, final FormatOptions opts) {\n        final int targetExponent = digitCount + exponent - decimalPos;\n        final int absTargetExponent = Math.abs(targetExponent);\n        final boolean includeExponent = shouldIncludeExponent(targetExponent, opts);\n        final boolean negativeExponent = targetExponent < 0;\n\n        // determine the size of the full formatted string, including the number of\n        // characters needed for the exponent digits\n        int size = getDigitStringSize(decimalPos, opts);\n        int exponentDigitCount = 0;\n        if (includeExponent) {\n            exponentDigitCount = absTargetExponent > 0\n                    ? (int) Math.floor(Math.log10(absTargetExponent)) + 1\n                    : 1;\n\n            size += opts.getExponentSeparatorChars().length + exponentDigitCount;\n            if (negativeExponent) {\n                ++size;\n            }\n        }\n\n        prepareOutput(size);\n\n        // append the portion before the exponent field\n        final int fractionStartIdx = appendWhole(decimalPos, opts);\n        appendFraction(0, fractionStartIdx, opts);\n\n        if (includeExponent) {\n            // append the exponent field\n            append(opts.getExponentSeparatorChars());\n\n            if (negativeExponent) {\n                append(opts.getMinusSign());\n            }\n\n            // append the exponent digits themselves; compute the\n            // string representation directly and add it to the output\n            // buffer to avoid the overhead of Integer.toString()\n            final char[] localizedDigits = opts.getDigits();\n            int rem = absTargetExponent;\n            for (int i = size - 1; i >= outputIdx; --i) {\n                outputChars[i] = localizedDigits[rem % DECIMAL_RADIX];\n                rem /= DECIMAL_RADIX;\n            }\n            outputIdx = size;\n        }\n\n        return outputString();\n    }",
        "called_methods": [
            "toScientificString",
            "abs",
            "shouldIncludeExponent",
            "getDigitStringSize",
            "floor",
            "log10",
            "getExponentSeparatorChars",
            "prepareOutput",
            "appendWhole",
            "appendFraction",
            "append",
            "getMinusSign",
            "getDigits",
            "outputString"
        ],
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "toScientificString",
        "javadoc": "/**\n * Formats a number as a string in scientific notation.\n *\n * @param decimalPos  The position of the decimal point in the formatted number.\n * @param opts        The format options to use when formatting the number.\n *\n * @return A string representation of the number in scientific notation.\n *\n * @throws Exception If an error occurs during formatting.\n */\n"
    },
    {
        "signature": "private void truncate(final int count)",
        "implementation": "private void truncate(final int count) {\n        // trim all trailing zero digits, making sure to leave\n        // at least one digit left\n        int nonZeroCount = count;\n        for (int i = count - 1;\n                i > 0 && digits[i] == 0;\n                --i) {\n            --nonZeroCount;\n        }\n        exponent += digitCount - nonZeroCount;\n        digitCount = nonZeroCount;\n    }",
        "called_methods": "",
        "repository": "commons-text-master-docbyai",
        "source": "commons-text-master-docbyai\\src\\main\\java\\org\\apache\\commons\\text\\numbers\\ParsedDecimal.java",
        "name": "truncate",
        "javadoc": "/**\n * Truncates the number to the specified number of digits.\n *\n * @param count The new number of digits. Must be greater than 0.\n */\n"
    }
]